{"version":3,"file":"index.js","sources":["../../../node_modules/@typhonjs-fvtt/svelte/node_modules/@typhonjs-svelte/lib/node_modules/svelte-persistent-store/dist/chunk.I6NEYSOQ.mjs","../../../node_modules/@typhonjs-fvtt/svelte/node_modules/@typhonjs-svelte/lib/node_modules/svelte-persistent-store/dist/chunk.HHIHGWA2.mjs","../../../node_modules/@typhonjs-fvtt/svelte/node_modules/@typhonjs-svelte/lib/src/modules/store/LocalStorage.js","../../../node_modules/@typhonjs-fvtt/svelte/node_modules/@typhonjs-svelte/lib/node_modules/svelte-persistent-store/dist/chunk.ZLJ3FCQ6.mjs","../../../node_modules/@typhonjs-fvtt/svelte/node_modules/@typhonjs-svelte/lib/src/modules/store/SessionStorage.js","../../../node_modules/@typhonjs-fvtt/svelte/node_modules/@typhonjs-utils/object/src/functions.js","../../../node_modules/@typhonjs-fvtt/svelte/src/store/TJSGameSettings.js"],"sourcesContent":["// src/generator.ts\nimport {writable as ogWritable, get as ogGet} from \"svelte/store\";\nimport {run_all, noop, is_function} from \"svelte/internal\";\nfunction isSimpleDeriver(deriver) {\n  return deriver.length < 2;\n}\nfunction generator(storage) {\n  function readable(key, value, start) {\n    return {\n      subscribe: writable(key, value, start).subscribe\n    };\n  }\n  function writable(key, value, start = noop) {\n    function wrap_start(ogSet) {\n      return start(function wrap_set(new_value) {\n        if (storage) {\n          storage.setItem(key, JSON.stringify(new_value));\n        }\n        return ogSet(new_value);\n      });\n    }\n    if (storage) {\n      if (storage.getItem(key)) {\n        value = JSON.parse(storage.getItem(key));\n      }\n      storage.setItem(key, JSON.stringify(value));\n    }\n    const ogStore = ogWritable(value, start ? wrap_start : void 0);\n    function set(new_value) {\n      if (storage) {\n        storage.setItem(key, JSON.stringify(new_value));\n      }\n      ogStore.set(new_value);\n    }\n    function update(fn) {\n      set(fn(ogGet(ogStore)));\n    }\n    function subscribe(run, invalidate = noop) {\n      return ogStore.subscribe(run, invalidate);\n    }\n    return {set, update, subscribe};\n  }\n  function derived(key, stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single ? [stores] : stores;\n    if (storage && storage.getItem(key)) {\n      initial_value = JSON.parse(storage.getItem(key));\n    }\n    return readable(key, initial_value, (set) => {\n      let inited = false;\n      const values = [];\n      let pending = 0;\n      let cleanup = noop;\n      const sync = () => {\n        if (pending) {\n          return;\n        }\n        cleanup();\n        const input = single ? values[0] : values;\n        if (isSimpleDeriver(fn)) {\n          set(fn(input));\n        } else {\n          const result = fn(input, set);\n          cleanup = is_function(result) ? result : noop;\n        }\n      };\n      const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {\n        values[i] = value;\n        pending &= ~(1 << i);\n        if (inited) {\n          sync();\n        }\n      }, () => {\n        pending |= 1 << i;\n      }));\n      inited = true;\n      sync();\n      return function stop() {\n        run_all(unsubscribers);\n        cleanup();\n      };\n    });\n  }\n  return {\n    readable,\n    writable,\n    derived,\n    get: ogGet\n  };\n}\n\nexport {\n  generator\n};\n","import {\n  generator\n} from \"./chunk.I6NEYSOQ.mjs\";\n\n// src/local.ts\nvar storage = typeof window !== \"undefined\" ? window.localStorage : void 0;\nvar g = generator(storage);\nvar readable = g.readable;\nvar writable = g.writable;\nvar derived = g.derived;\nvar get = g.get;\n\nexport {\n  readable,\n  writable,\n  derived,\n  get\n};\n","import { writable }  from 'svelte-persistent-store/local';\r\nimport { get }       from 'svelte/store';\r\n\r\nexport class LocalStorage\r\n{\r\n   /**\r\n    * @type {*}\r\n    */\r\n   #stores = new Map();\r\n\r\n   getItem(itemId, defaultValue)\r\n   {\r\n      let value;\r\n\r\n      const storageValue = localStorage.getItem(itemId);\r\n\r\n      if (storageValue !== void 0)\r\n      {\r\n         value = JSON.parse(storageValue);\r\n      }\r\n\r\n      return value;\r\n   }\r\n\r\n   getStore(itemId, defaultValue)\r\n   {\r\n      return s_GET_STORE(this.#stores, itemId, defaultValue);\r\n   }\r\n\r\n   setItem(itemId, value)\r\n   {\r\n      const store = s_GET_STORE(this.#stores, itemId);\r\n      store.set(value);\r\n   }\r\n\r\n   swapItemBoolean(itemId, defaultValue)\r\n   {\r\n      const store = s_GET_STORE(this.#stores, itemId, defaultValue);\r\n      const value = store.get();\r\n      const newValue = typeof value === 'boolean' ? !value : false;\r\n\r\n      store.set(newValue);\r\n      return newValue;\r\n   }\r\n}\r\n\r\nfunction s_GET_STORE(stores, itemId, defaultValue = void 0)\r\n{\r\n   let store = stores.get(itemId);\r\n   if (store === void 0)\r\n   {\r\n      store = s_CREATE_STORE(itemId, defaultValue);\r\n      stores.set(itemId, store);\r\n   }\r\n\r\n   return store;\r\n}\r\n\r\nfunction s_CREATE_STORE(itemId, defaultValue = void 0)\r\n{\r\n   try\r\n   {\r\n      if (localStorage.getItem(itemId))\r\n      {\r\n         defaultValue = JSON.parse(localStorage.getItem(itemId));\r\n      }\r\n   }\r\n   catch (err) { /**/ }\r\n\r\n   const store = writable(itemId, defaultValue);\r\n   store.get = () => get(store);\r\n\r\n   return store;\r\n}","import {\n  generator\n} from \"./chunk.I6NEYSOQ.mjs\";\n\n// src/session.ts\nvar storage = typeof window !== \"undefined\" ? window.sessionStorage : void 0;\nvar g = generator(storage);\nvar readable = g.readable;\nvar writable = g.writable;\nvar derived = g.derived;\nvar get = g.get;\n\nexport {\n  readable,\n  writable,\n  derived,\n  get\n};\n","import { writable }  from 'svelte-persistent-store/session';\r\nimport { get }       from 'svelte/store';\r\n\r\nexport class SessionStorage\r\n{\r\n   /**\r\n    * @type {*}\r\n    */\r\n   #stores = new Map();\r\n\r\n   getItem(itemId)\r\n   {\r\n      let value;\r\n\r\n      const storageValue = sessionStorage.getItem(itemId);\r\n\r\n      if (storageValue !== void 0)\r\n      {\r\n         value = JSON.parse(storageValue);\r\n      }\r\n\r\n      return value;\r\n   }\r\n\r\n   getStore(itemId, defaultValue)\r\n   {\r\n      return s_GET_STORE(this.#stores, itemId, defaultValue);\r\n   }\r\n\r\n   setItem(itemId, value)\r\n   {\r\n      const store = s_GET_STORE(this.#stores, itemId);\r\n      store.set(value);\r\n   }\r\n\r\n   swapItemBoolean(itemId, defaultValue)\r\n   {\r\n      const store = s_GET_STORE(this.#stores, itemId, defaultValue);\r\n      const value = store.get();\r\n      const newValue = typeof value === 'boolean' ? !value : false;\r\n\r\n      store.set(newValue);\r\n      return newValue;\r\n   }\r\n}\r\n\r\nfunction s_GET_STORE(stores, itemId, defaultValue = void 0)\r\n{\r\n   let store = stores.get(itemId);\r\n   if (store === void 0)\r\n   {\r\n      store = s_CREATE_STORE(itemId, defaultValue);\r\n      stores.set(itemId, store);\r\n   }\r\n\r\n   return store;\r\n}\r\n\r\nfunction s_CREATE_STORE(itemId, defaultValue = void 0)\r\n{\r\n   try\r\n   {\r\n      if (sessionStorage.getItem(itemId))\r\n      {\r\n         defaultValue = JSON.parse(sessionStorage.getItem(itemId));\r\n      }\r\n   }\r\n   catch (err) { /**/ }\r\n\r\n   const store = writable(itemId, defaultValue);\r\n   store.get = () => get(store);\r\n\r\n   return store;\r\n}","/**\r\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\r\n * equality tests, and validation.\r\n */\r\n\r\nconst s_TAG_MAP = '[object Map]';\r\nconst s_TAG_SET = '[object Set]';\r\nconst s_TAG_STRING = '[object String]';\r\n\r\n/**\r\n * @typedef {object} ValidationEntry - Provides data for a validation check.\r\n *\r\n * @property {string}               [type] - Optionally tests with a typeof check.\r\n *\r\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\r\n * against.\r\n *\r\n * @property {string}               [message] - Optional message to include.\r\n *\r\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\r\n *\r\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\r\n */\r\n\r\n/**\r\n * Freezes all entries traversed that are objects including entries in arrays.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\r\n *\r\n * @returns {object|Array} The frozen object.\r\n */\r\nexport function deepFreeze(data, skipFreezeKeys = [])\r\n{\r\n   /* istanbul ignore if */\r\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\r\n\r\n   /* istanbul ignore if */\r\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\r\n\r\n   return _deepFreeze(data, skipFreezeKeys);\r\n}\r\n\r\n/**\r\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\r\n * The result of the callback function is used to modify in place the given data.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\r\n *\r\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\r\n *                                  the given data.\r\n *\r\n * @returns {*} The data object.\r\n */\r\nexport function depthTraverse(data, func, modify = false)\r\n{\r\n   /* istanbul ignore if */\r\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\r\n\r\n   /* istanbul ignore if */\r\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\r\n\r\n   return _depthTraverse(data, func, modify);\r\n}\r\n\r\n/**\r\n * Returns a list of accessor keys by traversing the given object.\r\n *\r\n * @param {object}   data - An object to traverse for accessor keys.\r\n *\r\n * @returns {string[]} Accessor list.\r\n */\r\nexport function getAccessorList(data)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\r\n\r\n   return _getAccessorList(data);\r\n}\r\n\r\n/**\r\n * Tests for whether an object is iterable.\r\n *\r\n * @param {object} object - An object.\r\n *\r\n * @returns {boolean} Whether object is iterable.\r\n */\r\nexport function isIterable(object)\r\n{\r\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\r\n\r\n   return typeof object[Symbol.iterator] === 'function';\r\n}\r\n\r\n/**\r\n * Tests for whether an object is async iterable.\r\n *\r\n * @param {object} object - An object.\r\n *\r\n * @returns {boolean} Whether object is async iterable.\r\n */\r\nexport function isIterableAsync(object)\r\n{\r\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\r\n\r\n   return typeof object[Symbol.asyncIterator] === 'function';\r\n}\r\n\r\n/**\r\n * Tests for whether object is not null and a typeof object.\r\n *\r\n * @param {object} object - An object.\r\n *\r\n * @returns {boolean} Is it an object.\r\n */\r\nexport function isObject(object)\r\n{\r\n   return object !== null && typeof object === 'object';\r\n}\r\n\r\n/**\r\n * Safely returns keys on an object or an empty array if not an object.\r\n *\r\n * @param {object} object - An object.\r\n *\r\n * @returns {string[]} Object keys\r\n */\r\nexport function objectKeys(object)\r\n{\r\n   return object !== null && typeof object === 'object' ? Object.keys(object) : [];\r\n}\r\n\r\n/**\r\n * Safely returns an objects size. Note for String objects unicode is not taken into consideration.\r\n *\r\n * @param {object} object - An object.\r\n *\r\n * @returns {number} Size of object.\r\n */\r\nexport function objectSize(object)\r\n{\r\n   if (object === void 0 || object === null || typeof object !== 'object') { return 0; }\r\n\r\n   const tag = Object.prototype.toString.call(object);\r\n\r\n   if (tag === s_TAG_MAP || tag === s_TAG_SET) { return object.size; }\r\n\r\n   if (tag === s_TAG_STRING) { return object.length; }\r\n\r\n   return Object.keys(object).length;\r\n}\r\n\r\n/**\r\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk.\r\n *\r\n * @param {object}   data - An object to access entry data.\r\n *\r\n * @param {string}   accessor - A string describing the entries to access.\r\n *\r\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\r\n *\r\n * @returns {object} The data object.\r\n */\r\nexport function safeAccess(data, accessor, defaultValue = void 0)\r\n{\r\n   if (typeof data !== 'object') { return defaultValue; }\r\n   if (typeof accessor !== 'string') { return defaultValue; }\r\n\r\n   const access = accessor.split('.');\r\n\r\n   // Walk through the given object by the accessor indexes.\r\n   for (let cntr = 0; cntr < access.length; cntr++)\r\n   {\r\n      // If the next level of object access is undefined or null then return the empty string.\r\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\r\n\r\n      data = data[access[cntr]];\r\n   }\r\n\r\n   return data;\r\n}\r\n\r\n/**\r\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\r\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\r\n * value to set across all accessors.\r\n *\r\n * @param {object}         data - An object to access entry data.\r\n *\r\n * @param {Array<string>}  accessors - A string describing the entries to access.\r\n *\r\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\r\n *\r\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\r\n *                                             'set-undefined', 'sub'.\r\n *\r\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\r\n *\r\n *\r\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\r\n *                                          automatically.\r\n */\r\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\r\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\r\n\r\n   if (typeof value === 'object')\r\n   {\r\n      accessors.forEach((accessor) =>\r\n      {\r\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\r\n         safeSet(data, accessor, targetValue, operation, createMissing);\r\n      });\r\n   }\r\n   else\r\n   {\r\n      accessors.forEach((accessor) =>\r\n      {\r\n         safeSet(data, accessor, value, operation, createMissing);\r\n      });\r\n   }\r\n}\r\n\r\n/**\r\n * Compares a source object and values of entries against a target object. If the entries in the source object match\r\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\r\n * is returned.\r\n *\r\n * @param {object}   source - Source object.\r\n *\r\n * @param {object}   target - Target object.\r\n *\r\n * @returns {boolean} True if equal.\r\n */\r\nexport function safeEqual(source, target)\r\n{\r\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\r\n   {\r\n      return false;\r\n   }\r\n\r\n   const sourceAccessors = getAccessorList(source);\r\n\r\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\r\n   {\r\n      const accessor = sourceAccessors[cntr];\r\n\r\n      const sourceObjectValue = safeAccess(source, accessor);\r\n      const targetObjectValue = safeAccess(target, accessor);\r\n\r\n      if (sourceObjectValue !== targetObjectValue) { return false; }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk.\r\n *\r\n * @param {object}   data - An object to access entry data.\r\n *\r\n * @param {string}   accessor - A string describing the entries to access.\r\n *\r\n * @param {*}        value - A new value to set if an entry for accessor is found.\r\n *\r\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\r\n *                                       'set-undefined', 'sub'.\r\n *\r\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\r\n *                                          automatically.\r\n *\r\n * @returns {boolean} True if successful.\r\n */\r\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\r\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\r\n\r\n   const access = accessor.split('.');\r\n\r\n   // Walk through the given object by the accessor indexes.\r\n   for (let cntr = 0; cntr < access.length; cntr++)\r\n   {\r\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\r\n      if (Array.isArray(data))\r\n      {\r\n         const number = (+access[cntr]);\r\n\r\n         if (!Number.isInteger(number) || number < 0) { return false; }\r\n      }\r\n\r\n      if (cntr === access.length - 1)\r\n      {\r\n         switch (operation)\r\n         {\r\n            case 'add':\r\n               data[access[cntr]] += value;\r\n               break;\r\n\r\n            case 'div':\r\n               data[access[cntr]] /= value;\r\n               break;\r\n\r\n            case 'mult':\r\n               data[access[cntr]] *= value;\r\n               break;\r\n\r\n            case 'set':\r\n               data[access[cntr]] = value;\r\n               break;\r\n\r\n            case 'set-undefined':\r\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\r\n               break;\r\n\r\n            case 'sub':\r\n               data[access[cntr]] -= value;\r\n               break;\r\n         }\r\n      }\r\n      else\r\n      {\r\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\r\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\r\n\r\n         // Abort if the next level is null or not an object and containing a value.\r\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\r\n\r\n         data = data[access[cntr]];\r\n      }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Performs bulk setting of values to the given data object.\r\n *\r\n * @param {object}            data - The data object to set data.\r\n *\r\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\r\n *\r\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\r\n *                                                default (`set`).\r\n *\r\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\r\n *                                                   automatically.\r\n */\r\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\r\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\r\n\r\n   for (const accessor of Object.keys(accessorValues))\r\n   {\r\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\r\n\r\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\r\n   }\r\n}\r\n\r\n/**\r\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\r\n *\r\n * @param {object}                           data - The data object to test.\r\n *\r\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\r\n *\r\n * @param {string}                           [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validate(data, validationData = {}, dataName = 'data')\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\r\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\r\n\r\n   let result;\r\n\r\n   for (const key of Object.keys(validationData))\r\n   {\r\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\r\n\r\n      const entry = validationData[key];\r\n\r\n      switch (entry.test)\r\n      {\r\n         case 'array':\r\n            result = validateArray(data, key, entry, dataName);\r\n            break;\r\n\r\n         case 'entry':\r\n            result = validateEntry(data, key, entry, dataName);\r\n            break;\r\n\r\n         case 'entry|array':\r\n            result = validateEntryOrArray(data, key, entry, dataName);\r\n            break;\r\n      }\r\n   }\r\n\r\n   return result;\r\n}\r\n\r\n/**\r\n * Validates all array entries against potential type and expected tests.\r\n *\r\n * @param {object}            data - The data object to test.\r\n *\r\n * @param {string}            accessor - A string describing the entries to access.\r\n *\r\n * @param {object}            opts - Options object.\r\n *\r\n * @param {string}            [opts.type] - Tests with a typeof check.\r\n *\r\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\r\n *\r\n * @param {string}            [opts.message] - Optional message to include.\r\n *\r\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\r\n *\r\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\r\n *\r\n * @param {string}            [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\r\n error = true } = {}, dataName = 'data')\r\n{\r\n   const dataArray = safeAccess(data, accessor);\r\n\r\n   // A non-required entry is missing so return without validation.\r\n   if (!required && typeof dataArray === 'undefined') { return true; }\r\n\r\n   if (!Array.isArray(dataArray))\r\n   {\r\n      if (error)\r\n      {\r\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\r\n      }\r\n      else\r\n      {\r\n         return false;\r\n      }\r\n   }\r\n\r\n   if (typeof type === 'string')\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         if (!(typeof dataArray[cntr] === type))\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(TypeError,\r\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\r\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\r\n   // entries as a `typeof` test against expected.\r\n   if (Array.isArray(expected))\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         if (!expected.includes(dataArray[cntr]))\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\r\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n   else if (expected instanceof Set)\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         if (!expected.has(dataArray[cntr]))\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\r\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n   else if (typeof expected === 'function')\r\n   {\r\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\r\n      {\r\n         try\r\n         {\r\n            const result = expected(dataArray[cntr]);\r\n\r\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\r\n         }\r\n         catch (err)\r\n         {\r\n            if (error)\r\n            {\r\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\r\n                dataArray[cntr];\r\n\r\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\r\n                dataEntryString}' failed validation: ${err.message}.`);\r\n            }\r\n            else\r\n            {\r\n               return false;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\r\n *\r\n * @param {object}            data - The object data to validate.\r\n *\r\n * @param {string}            accessor - A string describing the entries to access.\r\n *\r\n * @param {object}            opts - Options object\r\n *\r\n * @param {string}            [opts.type] - Tests with a typeof check.\r\n *\r\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\r\n *\r\n * @param {string}            [opts.message] - Optional message to include.\r\n *\r\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\r\n *\r\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\r\n *\r\n * @param {string}            [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\r\n error = true } = {}, dataName = 'data')\r\n{\r\n   const dataEntry = safeAccess(data, accessor);\r\n\r\n   // A non-required entry is missing so return without validation.\r\n   if (!required && typeof dataEntry === 'undefined') { return true; }\r\n\r\n   if (type && typeof dataEntry !== type)\r\n   {\r\n      if (error)\r\n      {\r\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\r\n      }\r\n      else\r\n      {\r\n         return false;\r\n      }\r\n   }\r\n\r\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\r\n    (Array.isArray(expected) && !expected.includes(dataEntry)))\r\n   {\r\n      if (error)\r\n      {\r\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\r\n\r\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\r\n          JSON.stringify(expected)}.`);\r\n      }\r\n      else\r\n      {\r\n         return false;\r\n      }\r\n   }\r\n   else if (typeof expected === 'function')\r\n   {\r\n      try\r\n      {\r\n         const result = expected(dataEntry);\r\n\r\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\r\n      }\r\n      catch (err)\r\n      {\r\n         if (error)\r\n         {\r\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\r\n\r\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\r\n             err.message}.`);\r\n         }\r\n         else\r\n         {\r\n            return false;\r\n         }\r\n      }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Dispatches validation of data entry to string or array validation depending on data entry type.\r\n *\r\n * @param {object}            data - The data object to test.\r\n *\r\n * @param {string}            accessor - A string describing the entries to access.\r\n *\r\n * @param {ValidationEntry}   [entry] - A validation entry.\r\n *\r\n * @param {string}            [dataName='data'] - Optional name of data.\r\n *\r\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\r\n */\r\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\r\n{\r\n   const dataEntry = safeAccess(data, accessor);\r\n\r\n   let result;\r\n\r\n   if (Array.isArray(dataEntry))\r\n   {\r\n      result = validateArray(data, accessor, entry, dataName);\r\n   }\r\n   else\r\n   {\r\n      result = validateEntry(data, accessor, entry, dataName);\r\n   }\r\n\r\n   return result;\r\n}\r\n\r\n// Module private ---------------------------------------------------------------------------------------------------\r\n\r\n/**\r\n * Private implementation of depth traversal.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\r\n *\r\n * @returns {*} The frozen object.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _deepFreeze(data, skipFreezeKeys)\r\n{\r\n   if (Array.isArray(data))\r\n   {\r\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\r\n   }\r\n   else if (typeof data === 'object')\r\n   {\r\n      for (const key in data)\r\n      {\r\n         // eslint-disable-next-line no-prototype-builtins\r\n         if (data.hasOwnProperty(key) && !skipFreezeKeys.includes(key)) { _deepFreeze(data[key], skipFreezeKeys); }\r\n      }\r\n   }\r\n\r\n   return Object.freeze(data);\r\n}\r\n\r\n/**\r\n * Private implementation of depth traversal.\r\n *\r\n * @param {object|Array}   data - An object or array.\r\n *\r\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\r\n *\r\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\r\n *                                  the given data.\r\n *\r\n * @returns {*} The data object.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _depthTraverse(data, func, modify)\r\n{\r\n   if (modify)\r\n   {\r\n      if (Array.isArray(data))\r\n      {\r\n         for (let cntr = 0; cntr < data.length; cntr++)\r\n         {\r\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\r\n         }\r\n      }\r\n      else if (typeof data === 'object')\r\n      {\r\n         for (const key in data)\r\n         {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         data = func(data);\r\n      }\r\n   }\r\n   else\r\n   {\r\n      if (Array.isArray(data))\r\n      {\r\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\r\n      }\r\n      else if (typeof data === 'object')\r\n      {\r\n         for (const key in data)\r\n         {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         func(data);\r\n      }\r\n   }\r\n\r\n   return data;\r\n}\r\n\r\n/**\r\n * Private implementation of `getAccessorList`.\r\n *\r\n * @param {object}   data - An object to traverse.\r\n *\r\n * @returns {string[]} Accessor list.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _getAccessorList(data)\r\n{\r\n   const accessors = [];\r\n\r\n   for (const key in data)\r\n   {\r\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\r\n      {\r\n         if (typeof data[key] === 'object')\r\n         {\r\n            const childKeys = _getAccessorList(data[key]);\r\n\r\n            childKeys.forEach((childKey) =>\r\n            {\r\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\r\n            });\r\n         }\r\n         else\r\n         {\r\n            accessors.push(key);\r\n         }\r\n      }\r\n   }\r\n\r\n   return accessors;\r\n}\r\n\r\n/**\r\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\r\n *\r\n * @param {Error}    clazz - Error class to instantiate.\r\n *\r\n * @param {string}   message - An error message.\r\n *\r\n * @returns {*} Error of the clazz.\r\n * @ignore\r\n * @private\r\n */\r\nfunction _validateError(clazz, message = void 0)\r\n{\r\n   const error = new clazz(message);\r\n   error._objectValidateError = true;\r\n   return error;\r\n}\r\n","import { isIterable }      from '@typhonjs-utils/object';\r\nimport { get, writable }   from 'svelte/store';\r\n\r\n/**\r\n * Registers game settings and creates a backing Svelte store for each setting. It is possible to add multiple\r\n * `onChange` callbacks on registration.\r\n */\r\nexport class TJSGameSettings\r\n{\r\n   /**\r\n    * @type {*}\r\n    */\r\n   #stores = new Map();\r\n\r\n   getStore(key)\r\n   {\r\n      if (!this.#stores.has(key))\r\n      {\r\n         console.warn(`TJSGameSettings - getStore: '${key}' is not a registered setting.`);\r\n         return;\r\n      }\r\n\r\n      return s_GET_STORE(this.#stores, key);\r\n   }\r\n\r\n   register(moduleId, key, options = {})\r\n   {\r\n      if (typeof options !== 'object') { throw new TypeError(`TJSGameSettings - register: options is not an object.`); }\r\n\r\n      const onchangeFunctions = [];\r\n\r\n      // Handle loading any existing `onChange` callbacks.\r\n      if (isIterable(options?.onChange))\r\n      {\r\n         for (const entry of options.onChange)\r\n         {\r\n            if (typeof entry === 'function') { onchangeFunctions.push(entry); }\r\n         }\r\n      }\r\n      else if (typeof options.onChange === 'function')\r\n      {\r\n         onchangeFunctions.push(options.onChange);\r\n      }\r\n\r\n      // Provides an `onChange` callback to update the associated store.\r\n      onchangeFunctions.push((value) =>\r\n      {\r\n         const store = s_GET_STORE(this.#stores, key);\r\n         if (store) { store.set(value); }\r\n      });\r\n\r\n      // Provides the final onChange callback that iterates over all the stored onChange callbacks.\r\n      const onChange = (value) =>\r\n      {\r\n         for (const entry of onchangeFunctions) { entry(value); }\r\n      };\r\n\r\n      game.settings.register(moduleId, key, { ...options, onChange });\r\n\r\n      // Set new store value with existing setting or default value.\r\n      const newStore = s_GET_STORE(this.#stores, key);\r\n      newStore.set(game.settings.get(moduleId, key));\r\n   }\r\n\r\n   /**\r\n    * Registers multiple settings.\r\n    *\r\n    * @param {Iterable<GameSetting>} settings - An iterable list of game setting configurations to register.\r\n    */\r\n   registerAll(settings)\r\n   {\r\n      if (!isIterable(settings)) { throw new TypeError(`TJSGameSettings - registerAll: settings is not iterable.`); }\r\n\r\n      for (const entry of settings)\r\n      {\r\n         if (typeof entry !== 'object')\r\n         {\r\n            throw new TypeError(`TJSGameSettings - registerAll: entry in settings is not an object.`);\r\n         }\r\n\r\n         if (typeof entry.moduleId !== 'string')\r\n         {\r\n            throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'moduleId' attribute.`);\r\n         }\r\n\r\n         if (typeof entry.key !== 'string')\r\n         {\r\n            throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'key' attribute.`);\r\n         }\r\n\r\n         if (typeof entry.options !== 'object')\r\n         {\r\n            throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'options' attribute.`);\r\n         }\r\n\r\n         this.register(entry.moduleId, entry.key, entry.options);\r\n      }\r\n   }\r\n}\r\n\r\n\r\nfunction s_GET_STORE(stores, key)\r\n{\r\n   let store = stores.get(key);\r\n   if (store === void 0)\r\n   {\r\n      store = s_CREATE_STORE(key);\r\n      stores.set(key, store);\r\n   }\r\n\r\n   return store;\r\n}\r\n\r\nfunction s_CREATE_STORE()\r\n{\r\n   const store = writable(void 0);\r\n   store.get = () => get(store);\r\n\r\n   return store;\r\n}\r\n"],"names":["isSimpleDeriver","deriver","length","generator","storage","readable","key","value","start","subscribe","writable","noop","wrap_start","ogSet","wrap_set","new_value","setItem","JSON","stringify","getItem","parse","ogStore","ogWritable","set","update","fn","ogGet","run","invalidate","derived","stores","initial_value","single","Array","isArray","stores_array","inited","values","pending","cleanup","sync","input","result","is_function","unsubscribers","map","store","i","stop","run_all","get","window","localStorage","g","LocalStorage","Map","itemId","defaultValue","storageValue","getStore","s_GET_STORE","swapItemBoolean","newValue","s_CREATE_STORE","err","sessionStorage","SessionStorage"],"mappings":"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"}