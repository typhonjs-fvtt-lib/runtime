function e(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,n(e,t,"get"))}function t(e,t,s){return function(e,t,n){if(t.set)t.set.call(e,n);else {if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n;}}(e,n(e,t,"set"),s),s}function n(e,t,n){if(!t.has(e))throw new TypeError("attempted to "+n+" private field on non-instance");return t.get(e)}function s(e,t,n){!function(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}(e,t),t.set(e,n);}function i(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,o(e,t,"get"))}function r(e,t,n){return function(e,t,n){if(t.set)t.set.call(e,n);else {if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n;}}(e,o(e,t,"set"),n),n}function o(e,t,n){if(!t.has(e))throw new TypeError("attempted to "+n+" private field on non-instance");return t.get(e)}function a(e,t,n){!function(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}(e,t),t.set(e,n);}const h=/\s+/;function l(e,t,n,s,i){let r,o=0;if(n&&"object"==typeof n){void 0!==s&&"context"in i&&void 0===i.context&&(i.context=s);for(r=f(n);o<r.length;o++)t=l(e,t,r[o],n[r[o]],i);}else if(n&&h.test(n))for(r=n.split(h);o<r.length;o++)t=e(t,r[o],s,i);else t=e(t,n,s,i);return t}function c(e){const t=e.name;return ""!==t?`[${t}] `:""}function u(e,t,n,s){const i=s.events;if(i){const n=i[t];if(Array.isArray(n))for(const t of n)t.options.guard&&(e.guard=!0),t.options.type>e.type&&(e.type=t.options.type);}return e}const f=e=>null===e||"object"!=typeof e?[]:Object.keys(e);function d(e,t,n,s){const i=s.after,r=s.count+1;if(n){const s=e[t]=g(r,(function(){return n.apply(this,arguments)}),(()=>{i(t,s);}));s._callback=n;}return e}const g=function(e,t,n){let s;return function(...i){return --e>0&&(s=t.apply(this,i)),e<=1&&(n&&n.apply(this,i),n=void 0,t=void 0),s}};var p=new WeakMap,y=new WeakMap;class v{constructor(e=""){if(a(this,p,{writable:!0,value:""}),a(this,y,{writable:!0,value:void 0}),"string"!=typeof e)throw new TypeError("'name' is not a string");r(this,p,e),this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0;}before(e,t,n,s,i={}){if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const r={};if(this.isGuarded(t,r))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(r.names)}`),this;const o=l(d,{},t,n,{count:e,after:this.off.bind(this)});return "string"==typeof t&&null==s&&(n=void 0),this.on(o,n,s,i)}*entries(e){if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,y))if(e){for(const t in i(this,y))if(e.test(t))for(const e of i(this,y)[t])yield [t,e.callback,e.context,JSON.parse(JSON.stringify(e.options))];}else for(const e in i(this,y))for(const t of i(this,y)[e])yield [e,t.callback,t.context,JSON.parse(JSON.stringify(t.options))];}get eventCount(){return i(this,y)?Object.keys(i(this,y)).length:0}get callbackCount(){if(!i(this,y))return 0;let e=0;for(const t in i(this,y))e+=i(this,y)[t].length;return e}getOptions(e){const t=l(u,{guard:!1,type:0},e,void 0,{events:i(this,y)});let n;switch(t.type){case 1:n="sync";break;case 2:n="async";}return {guard:t.guard,type:n}}getType(e){switch(l(M,{type:0},e,void 0,{events:i(this,y)}).type){case 1:return "sync";case 2:return "async";default:return}}isGuarded(e,t={}){return t.names=[],t.guarded=!1,l($,t,e,void 0,{events:i(this,y)}).guarded}*keys(e){if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,y))if(e)for(const t in i(this,y))e.test(t)&&(yield t);else for(const e in i(this,y))yield e;}*keysWithOptions(e){if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,y))if(e)for(const t in i(this,y))e.test(t)&&(yield [t,this.getOptions(t)]);else for(const e in i(this,y))yield [e,this.getOptions(e)];}get name(){return i(this,p)}listenTo(e,t,n){if(!e)return this;const s={};if(j(e,t,s))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(s.names)}`),this;const i=e._listenId||(e._listenId=C("l")),r=this._listeningTo||(this._listeningTo={});let o=w=r[i];o||(this._listenId||(this._listenId=C("l")),o=w=r[i]=new x(this,e));const a=J(e,t,n,this);if(w=void 0,a)throw a;return o.interop&&o.on(t,n),this}listenToBefore(e,t,n,s){if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const i=l(d,{},n,s,{count:e,after:this.stopListening.bind(this,t)});return this.listenTo(t,i)}listenToOnce(e,t,n){const s=l(d,{},t,n,{count:1,after:this.stopListening.bind(this,e)});return this.listenTo(e,s)}off(e,t,n){return i(this,y)?(r(this,y,l(O,i(this,y),e,t,{context:n,listeners:this._listeners})),this):this}on(e,t,n,s={}){if(null==s||s.constructor!==Object)throw new TypeError("'options' must be an object literal.");const o={};return this.isGuarded(e,o)?(console.warn(`@typhonjs-plugin/eventbus ${c(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(o.names)}`),this):(r(this,y,l(R,i(this,y)||{},e,t,{context:n,ctx:this,options:s,listening:w})),w&&((this._listeners||(this._listeners={}))[w.id]=w,w.interop=!1),this)}once(e,t,n,s={}){const i={};if(this.isGuarded(e,i))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(i.names)}`),this;const r=l(d,{},e,t,{count:1,after:this.off.bind(this)});return "string"==typeof e&&null==n&&(t=void 0),this.on(r,t,n,s)}stopListening(e,t,n){const s=this._listeningTo;if(!s)return this;const i=e?[e._listenId]:f(s);for(let e=0;e<i.length;e++){const r=s[i[e]];if(!r)break;r.obj.off(t,n,this),r.interop&&r.off(t,n);}return this}trigger(e,...t){return i(this,y)?(S(D,N,i(this,y),e,void 0,t),this):this}async triggerAsync(e,...t){if(!i(this,y))return;const n=S(D,_,i(this,y),e,void 0,t);return void 0!==n?Array.isArray(n)?Promise.all(n).then((e=>{let t=[];for(const n of e)Array.isArray(n)?t=t.concat(n):void 0!==n&&t.push(n);return t.length>1?t:1===t.length?t[0]:void 0})):n:void 0}triggerDefer(e,...t){return setTimeout((()=>{this.trigger(e,...t);}),0),this}triggerSync(e,...t){if(i(this,y))return S(D,A,i(this,y),e,void 0,t)}}let w;var b=new WeakMap,E=new WeakMap,m=new WeakMap,P=new WeakMap,T=new WeakMap,k=new WeakMap;class x{constructor(e,t){a(this,b,{writable:!0,value:void 0}),a(this,E,{writable:!0,value:void 0}),a(this,m,{writable:!0,value:void 0}),a(this,P,{writable:!0,value:void 0}),a(this,T,{writable:!0,value:void 0}),a(this,k,{writable:!0,value:0}),r(this,E,e._listenId),r(this,m,e),r(this,P,t),r(this,T,!0);}cleanup(){delete i(this,m)._listeningTo[i(this,P)._listenId],i(this,T)||delete i(this,P)._listeners[i(this,E)];}get id(){return i(this,E)}get interop(){return i(this,T)}get obj(){return i(this,P)}incrementCount(){r(this,k,+i(this,k)+1);}on(e,t,n){return r(this,b,l(R,i(this,b)||{},e,t,{context:n,ctx:this,options:{},listening:this})),this}off(e,t){let n;i(this,T)?(r(this,b,l(O,i(this,b),e,t,{context:void 0,listeners:void 0})),n=!i(this,b)):(r(this,k,+i(this,k)-1),n=0===i(this,k)),n&&this.cleanup();}set interop(e){if("boolean"!=typeof e)throw new TypeError("'value' is not a boolean");r(this,T,e);}}const M=(e,t,n,s)=>{const i=s.events;if(i){const n=i[t];if(Array.isArray(n))for(const t of n)t.options.type>e.type&&(e.type=t.options.type);}return e},$=(e,t,n,s)=>{const i=s.events;if(i){const n=i[t];if(Array.isArray(n))for(const s of n)if(s.options.guard)return e.names.push(t),e.guarded=!0,e}return e},O=(e,t,n,s)=>{if(!e)return;const i=s.context,r=s.listeners;let o,a=0;if(t||i||n){for(o=t?[t]:f(e);a<o.length;a++){const s=e[t=o[a]];if(!s)break;const r=[];for(let e=0;e<s.length;e++){const o=s[e];if(n&&n!==o.callback&&n!==o.callback._callback||i&&i!==o.context)r.push(o);else {const e=o.listening;e&&e.off(t,n);}}r.length?e[t]=r:delete e[t];}return e}for(o=f(r);a<o.length;a++)r[o[a]].cleanup();},R=(e,t,n,s)=>{if(n){const i=e[t]||(e[t]=[]),r=s.context,o=s.ctx,a=s.listening,h=JSON.parse(JSON.stringify(s.options));switch(h.guard="boolean"==typeof h.guard&&h.guard,h.type){case"sync":h.type=1;break;case"async":h.type=2;break;default:h.type=0;}a&&a.incrementCount(),i.push({callback:n,context:r,ctx:r||o,options:h,listening:a});}return e},S=(e,t,n,s,i,r)=>{let o,a,l=0;if(s&&h.test(s))for(a=s.split(h);l<a.length;l++){const s=e(t,n,a[l],i,r),h=Array.isArray(o)?2:void 0!==o?1:0;if(Array.isArray(s))switch(h){case 0:o=s;break;case 1:o=[o].concat(s);break;case 2:o=o.concat(s);}else if(void 0!==s)switch(h){case 0:o=s;break;case 1:{const e=[o];e.push(s),o=e;break}case 2:o.push(s);}}else o=e(t,n,s,i,r);return o},D=(e,t,n,s,i)=>{let r;if(t){const s=t[n];let o=t.all;s&&o&&(o=o.slice()),s&&(r=e(s,i)),o&&(r=e(o,[n].concat(i)));}return r},N=(e,t)=>{let n,s=-1;const i=t[0],r=t[1],o=t[2],a=e.length;switch(t.length){case 0:for(;++s<a;)(n=e[s]).callback.call(n.ctx);return;case 1:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i);return;case 2:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i,r);return;case 3:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i,r,o);return;default:for(;++s<a;)(n=e[s]).callback.apply(n.ctx,t);return}},_=async(e,t)=>{let n,s=-1;const i=t[0],r=t[1],o=t[2],a=e.length,h=[];switch(t.length){case 0:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx);void 0!==t&&h.push(t);}break;case 1:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i);void 0!==t&&h.push(t);}break;case 2:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r);void 0!==t&&h.push(t);}break;case 3:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r,o);void 0!==t&&h.push(t);}break;default:for(;++s<a;){const i=(n=e[s]).callback.apply(n.ctx,t);void 0!==i&&h.push(i);}}return h.length>1?Promise.all(h).then((e=>{const t=e.filter((e=>void 0!==e));switch(t.length){case 0:return;case 1:return t[0];default:return t}})):1===h.length?h[0]:void 0},A=(e,t)=>{let n,s=-1;const i=t[0],r=t[1],o=t[2],a=e.length,h=[];switch(t.length){case 0:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx);void 0!==t&&h.push(t);}break;case 1:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i);void 0!==t&&h.push(t);}break;case 2:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r);void 0!==t&&h.push(t);}break;case 3:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r,o);void 0!==t&&h.push(t);}break;default:for(;++s<a;){const i=(n=e[s]).callback.apply(n.ctx,t);void 0!==i&&h.push(i);}}return h.length>1?h:1===h.length?h[0]:void 0},j=(e,t,n={})=>{let s=!1;try{const i=e.isGuarded(t,n);"boolean"==typeof i&&(s=i);}catch(e){s=!1,n.names=[],n.guarded=!1;}return s},J=(e,t,n,s)=>{try{e.on(t,n,s);}catch(e){return e}};let W=0;const C=(e="")=>{const t=""+ ++W;return e?`${e}${t}`:t};var L=new WeakMap,U=new WeakMap;class I{constructor(e){a(this,L,{writable:!0,value:void 0}),a(this,U,{writable:!0,value:void 0}),r(this,L,e),Object.seal(this);}before(e,t,n,s,r={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const o={};if(i(this,L).isGuarded(t,o))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(o.names)}`),this;const a=l(d,{},t,n,{count:e,after:this.off.bind(this)});return "string"==typeof t&&null==s&&(n=void 0),this.on(a,n,s,r)}createProxy(){return new I(i(this,L))}destroy(){null!==i(this,L)&&this.off(),r(this,U,void 0),r(this,L,null);}*entries(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const t of i(this,L).entries(e))yield t;}get eventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).eventCount}get callbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).callbackCount}*keys(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const t of i(this,L).keys(e))yield t;}*keysWithOptions(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const t of i(this,L).keysWithOptions(e))yield t;}get isDestroyed(){return null===i(this,L)}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return `proxy-${i(this,L).name}`}get proxyEventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,U)?Object.keys(i(this,U)).length:0}get proxyCallbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!i(this,U))return 0;let e=0;for(const t in i(this,U))e+=i(this,U)[t].length;return e}getOptions(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).getOptions(e)}getType(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).getType(e)}isGuarded(e,t={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).isGuarded(e,t)}off(e,t,n){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return r(this,U,l(K,i(this,U)||{},e,t,{context:n,eventbus:i(this,L)})),this}on(e,t,n,s={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(null==s||s.constructor!==Object)throw new TypeError("'options' must be an object literal.");const o={};if(i(this,L).isGuarded(e,o))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(o.names)}`),this;const a={context:n,ctx:this,options:s};return r(this,U,l(G,i(this,U)||{},e,t,a)),i(this,L).on(e,t,a.ctx,s),this}once(e,t,n,s={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");const r={};if(i(this,L).isGuarded(e,r))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(r.names)}`),this;const o=l(d,{},e,t,{count:1,after:this.off.bind(this)});return "string"==typeof e&&null==n&&(t=void 0),this.on(o,t,n,s)}*proxyEntries(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,U))if(e){for(const t in i(this,U))if(e.test(t))for(const e of i(this,U)[t])yield [t,e.callback,e.context,JSON.parse(JSON.stringify(e.options))];}else for(const e in i(this,U))for(const t of i(this,U)[e])yield [e,t.callback,t.context,JSON.parse(JSON.stringify(t.options))];}*proxyKeys(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,U))if(e)for(const t in i(this,U))e.test(t)&&(yield t);else for(const e in i(this,U))yield e;}*proxyKeysWithOptions(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,U))if(e)for(const t in i(this,U))e.test(t)&&(yield [t,i(this,L).getOptions(t)]);else for(const e in i(this,U))yield [e,i(this,L).getOptions(e)];}trigger(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).trigger(e,...t),this}triggerAsync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).triggerAsync(e,...t)}triggerDefer(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).triggerDefer(e,...t),this}triggerSync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).triggerSync(e,...t)}}const K=(e,t,n,s)=>{if(!e)return;const i=s.context,r=s.eventbus,o=t?[t]:f(e);for(let s=0;s<o.length;s++){const a=e[t=o[s]];if(!a)break;const h=[];for(let e=0;e<a.length;e++){const s=a[e];n&&n!==s.callback&&n!==s.callback._callback||i&&i!==s.context?h.push(s):r.off(t,s.callback||s.callback._callback,s.context||s.ctx);}h.length?e[t]=h:delete e[t];}return e},G=(e,t,n,s)=>{if(n){const i=e[t]||(e[t]=[]),r=s.context,o=s.ctx,a=JSON.parse(JSON.stringify(s.options));switch(a.guard=void 0!==a.guard&&"boolean"==typeof a.guard&&a.guard,a.type){case"sync":a.type=1;break;case"async":a.type=2;break;default:a.type=0;}s.ctx=r||o,i.push({callback:n,context:r,ctx:s.ctx,options:a});}return e};var z=new WeakMap,V=new WeakMap;class B{constructor(){a(this,z,{writable:!0,value:void 0}),a(this,V,{writable:!0,value:void 0});}static initialize(e,t){if(void 0!==t&&"string"!=typeof t)throw new TypeError("'name' is not a string.");const n=new B;return r(n,z,e),r(n,V,void 0===t?e.name:t),Object.seal(n),{destroy:function(){n.isDestroyed||(r(n,z,null),this&&(this.eventbusSecure=void 0));},setEventbus:function(e,t){if(void 0!==t&&"string"!=typeof t)throw new TypeError("'name' is not a string.");n.isDestroyed||(void 0===t&&i(n,V)===i(n,z).name?r(n,V,e.name):void 0!==t&&r(n,V,t),r(n,z,e));},eventbusSecure:n}}*keys(e){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");for(const t of i(this,z).keys(e))yield t;}*keysWithOptions(e){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");for(const t of i(this,z).keysWithOptions(e))yield t;}get isDestroyed(){return null===i(this,z)}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,V)}getOptions(e){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).getOptions(e)}getType(e){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).getType(e)}trigger(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).trigger(e,...t),this}triggerAsync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).triggerAsync(e,...t)}triggerDefer(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).triggerDefer(e,...t),this}triggerSync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).triggerSync(e,...t)}}const q=new v("mainEventbus"),F=new v("pluginEventbus"),H=new v("testEventbus"),Q=/^(https?:\/\/|file:\/\/)/;var X=new WeakMap,Y=new WeakMap,Z=new WeakMap,ee=new WeakMap,te=new WeakMap,ne=new WeakMap,se=new WeakMap;class ie{constructor(e,n,i,r){s(this,X,{writable:!0,value:void 0}),s(this,Y,{writable:!0,value:void 0}),s(this,Z,{writable:!0,value:void 0}),s(this,ee,{writable:!0,value:void 0}),s(this,te,{writable:!0,value:void 0}),s(this,ne,{writable:!0,value:void 0}),s(this,se,{writable:!0,value:void 0}),t(this,X,n),t(this,Y,!0),t(this,Z,e),t(this,te,i),t(this,ne,r);}get data(){return e(this,X)}get enabled(){return e(this,Y)}get importmeta(){return e(this,ee)}reset(){try{t(this,se,void 0),t(this,ee,void 0),delete e(this,te)._eventbus;}catch(e){}}set enabled(n){if(t(this,Y,n),n){if(void 0!==e(this,ne)&&Array.isArray(e(this,se))){for(const t of e(this,se))e(this,ne).on(...t);t(this,se,void 0);}}else void 0!==e(this,ne)&&(t(this,se,Array.from(e(this,ne).proxyEntries())),e(this,ne).off());}get eventbusProxy(){return e(this,ne)}get instance(){return e(this,te)}get name(){return e(this,Z)}set eventbusProxy(e){t(this,ne,e);}set importmeta(e){t(this,ee,e);}set instance(e){t(this,te,e);}}function re(e,t=[]){if("object"!=typeof e)throw new TypeError("'data' is not an 'object'.");if(!Array.isArray(t))throw new TypeError("'skipFreezeKeys' is not an 'array'.");return he(e,t)}function oe(e){return null!=e&&"object"==typeof e&&"function"==typeof e[Symbol.iterator]}function ae(e){return null!==e&&"object"==typeof e}function he(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)he(e[n],t);else if("object"==typeof e)for(const n in e)e.hasOwnProperty(n)&&!t.includes(n)&&he(e[n],t);return Object.freeze(e)}class le{constructor(e={},t={}){this.data=Object.assign(JSON.parse(JSON.stringify(e)),t),this.eventbus=void 0,this.pluginName=void 0,this.pluginOptions=void 0;}}async function ce({method:e,manager:t,copyProps:n={},passthruProps:s={},plugins:i,options:r,errorCheck:o=!0}){if("string"!=typeof e)throw new TypeError("'method' is not a string.");if("object"!=typeof s)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof n)throw new TypeError("'copyProps' is not an object.");if(void 0===r&&(r=t.getOptions()),void 0===i&&(i=t.getPluginMapKeys()),"string"!=typeof i&&!oe(i))throw new TypeError("'plugins' is not a string or iterable.");let a=0;const h=[];let l=!1,c=!1;const u=new le(n,s),f=[];if("string"==typeof i){const n=t.getPluginEntry(i);if(void 0!==n&&n.enabled&&n.instance&&(c=!0,"function"==typeof n.instance[e])){u.eventbus=n.eventbusProxy,u.pluginName=n.name,u.pluginOptions=n.data.plugin.options;const t=n.instance[e](u);null!=t&&f.push(t),l=!0,a++,h.push(n.name);}}else for(const n of i){const s=t.getPluginEntry(n);if(void 0!==s&&s.enabled&&s.instance&&(c=!0,"function"==typeof s.instance[e])){u.eventbus=s.eventbusProxy,u.pluginName=s.name,u.pluginOptions=s.data.plugin.options;const t=s.instance[e](u);null!=t&&f.push(t),l=!0,a++,h.push(s.name);}}if(o&&r.throwNoPlugin&&!c)throw new Error("PluginManager failed to find any target plugins.");if(o&&r.throwNoMethod&&!l)throw new Error(`PluginManager failed to invoke '${e}'.`);return u.data.$$plugin_invoke_count=a,u.data.$$plugin_invoke_names=h,await Promise.all(f),u.data}const ue=/^([.]{1,2}[\\|/])+/g,fe=/[\\]/g,de=/^(https?|file):/g;function ge(e){let t=e;return e instanceof URL?t=e.pathname:e.match(de)&&(t=new URL(e).pathname),t=t.replace(ue,""),t=t.replace(fe,"\\\\"),t}function pe(e){return "object"==typeof e&&"string"==typeof e.name&&(void 0===e.target||"string"==typeof e.target||e.target instanceof URL)&&(void 0===e.options||"object"==typeof e.options)}function ye(e){return "function"==typeof e.onPluginLoad?e:e.default?e.default:e}var ve=new WeakMap,we=new WeakMap,be=new WeakMap,Ee=new WeakMap,me=new WeakMap,Pe=new WeakMap,Te=new WeakMap;class ke{constructor(t={}){if(s(this,ve,{writable:!0,value:null}),s(this,we,{writable:!0,value:[]}),s(this,be,{writable:!0,value:[]}),s(this,Ee,{writable:!0,value:{noEventAdd:!1,noEventDestroy:!0,noEventRemoval:!1,noEventSetEnabled:!0,noEventSetOptions:!0,throwNoMethod:!1,throwNoPlugin:!1}}),s(this,me,{writable:!0,value:new Set}),s(this,Pe,{writable:!0,value:new Map}),s(this,Te,{writable:!0,value:[]}),!ae(t))throw new TypeError("'options' is not an object.");if(void 0!==t.eventbus&&!ae(t.eventbus))throw new TypeError("'options.eventbus' is not an Eventbus.");if(void 0!==t.eventPrepend&&"string"!=typeof t.eventPrepend)throw new TypeError("'options.eventPrepend' is not a string.");if(void 0!==t.manager&&!ae(t.manager))throw new TypeError("'options.manager' is not an object.");if(void 0!==t.PluginSupport&&"function"!=typeof t.PluginSupport&&!oe(t.PluginSupport))throw new TypeError("'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.");if(oe(t.PluginSupport))for(const n of t.PluginSupport)e(this,Te).push(new n(this));else void 0!==t.PluginSupport&&e(this,Te).push(new t.PluginSupport(this));this.setOptions(t.manager||{}),this.setEventbus({eventbus:void 0!==t.eventbus?t.eventbus:new v,eventPrepend:t.eventPrepend});}async add(t,n){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("object"!=typeof t)throw new TypeError("'pluginConfig' is not an object.");if("string"!=typeof t.name)throw new TypeError(`'pluginConfig.name' is not a string for entry:\n${JSON.stringify(t,null,3)}`);if(void 0!==t.target&&"string"!=typeof t.target&&!(t.target instanceof URL))throw new TypeError(`'pluginConfig.target' is not a string or URL for entry:\n${JSON.stringify(t,null,3)}`);if(void 0!==t.options&&"object"!=typeof t.options)throw new TypeError(`'pluginConfig.options' is not an object for entry:\n${JSON.stringify(t,null,3)}`);if(void 0!==n&&"object"!=typeof n)throw new TypeError(`'moduleData' is not an object for entry:\n${JSON.stringify(t,null,3)}`);if(e(this,Pe).has(t.name))throw new Error(`A plugin already exists with name: ${t.name} for entry:\n${JSON.stringify(t,null,3)}`);if(e(this,me).has(t.name))throw new Error(`A plugin is already being loaded with name: ${t.name} for entry:\n${JSON.stringify(t,null,3)}`);let s,i,r;if(e(this,me).add(t.name),"object"==typeof t.instance||"function"==typeof t.instance)s=t.instance,i=t.name,r="instance";else {i=t.target||t.name;try{const t=await class{static async load({modulepath:e,resolveModule:t}={}){if(!(e instanceof URL)&&"string"!=typeof e)throw new TypeError("'modulepath' is not a string or URL");if(void 0!==t&&"function"!=typeof t)throw new TypeError("'resolveModule' is not a function");const n=await import(e),s=e instanceof URL?e.toString():e,i="import-"+(e instanceof URL||"string"==typeof e&&e.match(Q)?"url":"path");return {filepath:s,instance:void 0!==t?t(n):n,isESM:!0,loadpath:s,module:n,modulepath:e,type:i}}}.load({modulepath:i,resolveModule:ye});null!==e(this,ve)&&e(this,ve).trigger("log:debug",`@typhonjs-plugin/manager - ${t.isESM?"import":"require"}: ${t.loadpath}`),s=t.instance,r=t.type;}catch(n){throw e(this,me).delete(t.name),new Error(`@typhonjs-plugin/manager - Could not load target: ${i}\n\nPluginConfig:\n${JSON.stringify(t,null,3)}\n\n${n}`)}}i instanceof URL&&(i=i.toString());const o=JSON.parse(JSON.stringify({manager:{eventPrepend:this._eventPrepend,scopedName:`${this._eventPrepend}:${t.name}`},module:n||{},plugin:{name:t.name,target:i,targetEscaped:ge(i),type:r,options:t.options||{}}}));re(o,["manager"]);const a=null!==e(this,ve)&&void 0!==e(this,ve)?new I(e(this,ve)):void 0,h=new ie(t.name,o,s,a);e(this,Pe).set(t.name,h),e(this,me).delete(t.name);const l=await ce({method:"onPluginLoad",manager:this,plugins:t.name,errorCheck:!1});return "object"==typeof l.importmeta&&(h.importmeta=l.importmeta,"object"==typeof l.importmeta.hot&&"function"==typeof l.importmeta.hot.accept&&l.importmeta.hot.accept((({module:e})=>{this.reload({plugin:t.name,instance:ye(e)});}))),e(this,ve)&&await e(this,ve).triggerAsync("typhonjs:plugin:manager:plugin:added",o),o}async addAll(e,t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!oe(e))throw new TypeError("'pluginConfigs' is not iterable.");const n=[];for(const s of e){const e=await this.add(s,t);e&&n.push(e);}return n}async _addEventbus(t,n){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventAdd?void 0:this.add(t,n)}async _addAllEventbus(t,n){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventAdd?[]:this.addAll(t,n)}createEventbusProxy(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(null===e(this,ve))throw new ReferenceError("No eventbus assigned to plugin manager.");const t=new I(e(this,ve));return e(this,we).push(t),t}createEventbusSecure(t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(null===e(this,ve))throw new ReferenceError("No eventbus assigned to plugin manager.");const n=B.initialize(e(this,ve),t);return e(this,be).push(n),n.eventbusSecure}async destroy(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");const n=await this.removeAll();for(const t of e(this,be))t.destroy();t(this,be,[]);for(const t of e(this,we))t.destroy();t(this,we,[]),null!==e(this,ve)&&void 0!==e(this,ve)&&(e(this,ve).off(`${this._eventPrepend}:async:add`,this._addEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:add:all`,this._addAllEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:destroy:manager`,this._destroyEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:remove`,this._removeEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:remove:all`,this._removeAllEventbus,this),e(this,ve).off(`${this._eventPrepend}:get:enabled`,this.getEnabled,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:by:event`,this.getPluginByEvent,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:data`,this.getPluginData,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:events`,this.getPluginEvents,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:names`,this.getPluginNames,this),e(this,ve).off(`${this._eventPrepend}:get:options`,this.getOptions,this),e(this,ve).off(`${this._eventPrepend}:has:plugin`,this.hasPlugins,this),e(this,ve).off(`${this._eventPrepend}:is:valid:config`,this.isValidConfig,this),e(this,ve).off(`${this._eventPrepend}:set:enabled`,this._setEnabledEventbus,this),e(this,ve).off(`${this._eventPrepend}:set:options`,this._setOptionsEventbus,this));for(const t of e(this,Te))await t.destroy({eventbus:e(this,ve),eventPrepend:this._eventPrepend});return t(this,Te,[]),t(this,Pe,null),t(this,ve,null),n}async _destroyEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventDestroy?[]:this.destroy()}get isDestroyed(){return null===e(this,Pe)||void 0===e(this,Pe)}getEnabled({plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof t&&!oe(t))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof t){const n=e(this,Pe).get(t);return void 0!==n&&n.enabled}const n=[];let s=0;for(const i of t){const t=e(this,Pe).get(i),r=void 0!==t;n.push({plugin:i,enabled:r&&t.enabled,loaded:r}),s++;}if(0===s)for(const[t,s]of e(this,Pe).entries()){const e=void 0!==s;n.push({plugin:t,enabled:e&&s.enabled,loaded:e});}return n}getEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,ve)}getOptions(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return JSON.parse(JSON.stringify(e(this,Ee)))}getPluginByEvent({event:e}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e&&!(e instanceof RegExp))throw new TypeError("'event' is not a string or RegExp.");const t=this.getPluginEvents(),n=[];if("string"==typeof e)for(const s of t)s.events.includes(e)&&n.push(s.plugin);else for(const s of t)for(const t of s.events)if(e.test(t)){n.push(s.plugin);break}return n}getPluginData({plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof t&&!oe(t))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof t){const n=e(this,Pe).get(t);return void 0!==n?JSON.parse(JSON.stringify(n.data)):void 0}const n=[];let s=0;for(const i of t){const t=e(this,Pe).get(i);void 0!==t&&n.push(JSON.parse(JSON.stringify(t.data))),s++;}if(0===s)for(const t of e(this,Pe).values())void 0!==t&&n.push(JSON.parse(JSON.stringify(t.data)));return n}getPluginEntry(t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Pe).get(t)}getPluginEvents({plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof t&&!oe(t))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof t){const n=e(this,Pe).get(t);return void 0!==n&&n.eventbusProxy?Array.from(n.eventbusProxy.proxyKeys()).sort():[]}const n=[];let s=0;for(const i of t){const t=e(this,Pe).get(i);void 0!==t&&n.push({plugin:i,events:t.eventbusProxy?Array.from(t.eventbusProxy.proxyKeys()).sort():[]}),s++;}if(0===s)for(const t of e(this,Pe).values())void 0!==t&&n.push({plugin:t.name,events:t.eventbusProxy?Array.from(t.eventbusProxy.proxyKeys()).sort():[]});return n}getPluginMapKeys(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Pe).keys()}getPluginMapValues(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Pe).values()}getPluginNames({enabled:t}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(void 0!==t&&"boolean"!=typeof t)throw new TypeError("'enabled' is not a boolean.");const n=void 0===t,s=[];for(const i of e(this,Pe).values())(n||i.enabled===t)&&s.push(i.name);return s.sort()}hasPlugins({plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof t&&!oe(t))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof t)return e(this,Pe).has(t);let n=0;for(const s of t){if(!e(this,Pe).has(s))return !1;n++;}return 0!==n||0!==e(this,Pe).size}isValidConfig(e){return pe(e)}async reload({plugin:t,instance:n,silent:s=!1}){if("string"!=typeof t)throw new TypeError("'plugin' is not a string.");if(void 0!==n&&"object"!=typeof n)throw new TypeError("'instance' is not an object.");if("boolean"!=typeof s)throw new TypeError("'silent' is not a boolean.");const i=e(this,Pe).get(t);if(void 0===i)return !1;let r,o;try{r=(await ce({method:"onPluginUnload",manager:this,plugins:t,errorCheck:!1})).state;}catch(e){o=e;}i.reset(),i.eventbusProxy instanceof I&&i.eventbusProxy.off(),"object"==typeof n&&(i.instance=n);const a=await ce({method:"onPluginLoad",manager:this,plugins:t,passthruProps:{state:r},errorCheck:!1});try{e(this,ve)&&!s&&await e(this,ve).triggerAsync("typhonjs:plugin:manager:plugin:reloaded",JSON.parse(JSON.stringify(i.data)));}catch(e){void 0===o&&(o=e);}if("object"==typeof a.importmeta&&(i.importmeta=a.importmeta,"object"==typeof a.importmeta.hot&&"function"==typeof a.importmeta.hot.accept&&a.importmeta.hot.accept((({module:e})=>{this.reload({plugin:t,instance:ye(e)});}))),o)throw o;return !0}async remove({plugins:t}){var n=this;if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof t&&!oe(t))throw new TypeError("'plugins' is not a string or iterable.");const s=async function(t){const s=[],i=t.name;try{await ce({method:"onPluginUnload",manager:n,plugins:i,errorCheck:!1});}catch(e){s.push(e);}t.reset(),t.eventbusProxy instanceof I&&t.eventbusProxy.destroy(),e(n,Pe).delete(i);try{e(n,ve)&&await e(n,ve).triggerAsync("typhonjs:plugin:manager:plugin:removed",JSON.parse(JSON.stringify(t.data)));}catch(e){s.push(e);}return {plugin:i,success:0===s.length,errors:s}},i=[];if("string"==typeof t){const n=e(this,Pe).get(t);void 0!==n&&i.push(await s(n));}else for(const n of t){const t=e(this,Pe).get(n);void 0!==t&&i.push(await s(t));}return i}async removeAll(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.remove({plugins:Array.from(e(this,Pe).keys())})}async _removeEventbus(t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventRemoval?[]:this.remove(t)}async _removeAllEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventRemoval?[]:this.removeAll()}setEnabled({enabled:t,plugins:n=[]}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof n&&!oe(n))throw new TypeError("'plugins' is not a string or iterable.");if("boolean"!=typeof t)throw new TypeError("'enabled' is not a boolean.");const s=n=>{void 0!==n&&(n.enabled=t,e(this,ve)&&e(this,ve).trigger("typhonjs:plugin:manager:plugin:enabled",Object.assign({enabled:t},JSON.parse(JSON.stringify(n.data)))));};"string"==typeof n&&s(e(this,Pe).get(n));let i=0;for(const t of n)s(e(this,Pe).get(t)),i++;if(0===i)for(const t of e(this,Pe).values())s(t);}_setEnabledEventbus(t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");e(this,Ee).noEventSetEnabled||this.setEnabled(t);}async setEventbus({eventbus:n,eventPrepend:s="plugins"}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!ae(n))throw new TypeError("'eventbus' is not an Eventbus.");if("string"!=typeof s)throw new TypeError("'eventPrepend' is not a string.");if(n===e(this,ve))return;const i=this._eventPrepend;if(this._eventPrepend=s,e(this,Pe).size>0){await ce({method:"onPluginUnload",manager:this,errorCheck:!1});for(const t of e(this,Pe).values()){try{delete t.instance._eventbus;}catch(e){}t.data.manager.eventPrepend=s,t.data.manager.scopedName=`${s}:${t.name}`,t.eventbusProxy instanceof I&&t.eventbusProxy.destroy(),t.eventbusProxy=new I(n),t.enabled&&await ce({method:"onPluginLoad",manager:this,plugins:t.name,errorCheck:!1});}}null!==e(this,ve)&&(e(this,ve).off(`${i}:async:add`,this._addEventbus,this),e(this,ve).off(`${i}:async:add:all`,this._addAllEventbus,this),e(this,ve).off(`${i}:async:destroy:manager`,this._destroyEventbus,this),e(this,ve).off(`${i}:async:remove`,this._removeEventbus,this),e(this,ve).off(`${i}:async:remove:all`,this._removeAllEventbus,this),e(this,ve).off(`${i}:get:enabled`,this.getEnabled,this),e(this,ve).off(`${i}:get:options`,this.getOptions,this),e(this,ve).off(`${i}:get:plugin:by:event`,this.getPluginByEvent,this),e(this,ve).off(`${i}:get:plugin:data`,this.getPluginData,this),e(this,ve).off(`${i}:get:plugin:events`,this.getPluginEvents,this),e(this,ve).off(`${i}:get:plugin:names`,this.getPluginNames,this),e(this,ve).off(`${i}:has:plugin`,this.hasPlugins,this),e(this,ve).off(`${i}:is:valid:config`,this.isValidConfig,this),e(this,ve).off(`${i}:set:enabled`,this._setEnabledEventbus,this),e(this,ve).off(`${i}:set:options`,this._setOptionsEventbus,this)),n.on(`${s}:async:add`,this._addEventbus,this,{guard:!0}),n.on(`${s}:async:add:all`,this._addAllEventbus,this,{guard:!0}),n.on(`${s}:async:destroy:manager`,this._destroyEventbus,this,{guard:!0}),n.on(`${s}:async:remove`,this._removeEventbus,this,{guard:!0}),n.on(`${s}:async:remove:all`,this._removeAllEventbus,this,{guard:!0}),n.on(`${s}:get:enabled`,this.getEnabled,this,{guard:!0}),n.on(`${s}:get:options`,this.getOptions,this,{guard:!0}),n.on(`${s}:get:plugin:by:event`,this.getPluginByEvent,this,{guard:!0}),n.on(`${s}:get:plugin:data`,this.getPluginData,this,{guard:!0}),n.on(`${s}:get:plugin:events`,this.getPluginEvents,this,{guard:!0}),n.on(`${s}:get:plugin:names`,this.getPluginNames,this,{guard:!0}),n.on(`${s}:has:plugin`,this.hasPlugins,this,{guard:!0}),n.on(`${s}:is:valid:config`,this.isValidConfig,this,{guard:!0}),n.on(`${s}:set:enabled`,this._setEnabledEventbus,this,{guard:!0}),n.on(`${s}:set:options`,this._setOptionsEventbus,this,{guard:!0});for(const t of e(this,Te))t.setEventbus({oldEventbus:e(this,ve),newEventbus:n,oldPrepend:i,newPrepend:s});for(const t of e(this,be))t.setEventbus(n);t(this,ve,n);}setOptions(t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!ae(t))throw new TypeError("'options' is not an object.");"boolean"==typeof t.noEventAdd&&(e(this,Ee).noEventAdd=t.noEventAdd),"boolean"==typeof t.noEventDestroy&&(e(this,Ee).noEventDestroy=t.noEventDestroy),"boolean"==typeof t.noEventRemoval&&(e(this,Ee).noEventRemoval=t.noEventRemoval),"boolean"==typeof t.noEventSetEnabled&&(e(this,Ee).noEventSetEnabled=t.noEventSetEnabled),"boolean"==typeof t.noEventSetOptions&&(e(this,Ee).noEventSetOptions=t.noEventSetOptions),"boolean"==typeof t.throwNoMethod&&(e(this,Ee).throwNoMethod=t.throwNoMethod),"boolean"==typeof t.throwNoPlugin&&(e(this,Ee).throwNoPlugin=t.throwNoPlugin);for(const n of e(this,Te))n.setOptions(t);}_setOptionsEventbus(t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");e(this,Ee).noEventSetOptions||this.setOptions(t);}}var xe=new WeakMap;class Me{constructor(e){s(this,xe,{writable:!0,value:null}),t(this,xe,e);}get isDestroyed(){return null===e(this,xe)||e(this,xe).isDestroyed}get options(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,xe).getOptions()}get pluginManager(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,xe)}async destroy({eventbus:e,eventPrepend:n}){null!=e&&(e.off(`${n}:async:invoke`,this.invokeAsync,this),e.off(`${n}:async:invoke:event`,this.invokeAsyncEvent,this),e.off(`${n}:get:method:names`,this.getMethodNames,this),e.off(`${n}:has:method`,this.hasMethod,this),e.off(`${n}:invoke`,this.invoke,this),e.off(`${n}:sync:invoke`,this.invokeSync,this),e.off(`${n}:sync:invoke:event`,this.invokeSyncEvent,this)),t(this,xe,null);}getMethodNames({enabled:e,plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(void 0!==e&&"boolean"!=typeof e)throw new TypeError("'enabled' is not a boolean.");if("string"!=typeof t&&!oe(t))throw new TypeError("'plugins' is not a string or iterable.");"string"==typeof t&&(t=[t]);const n=void 0===e,s={};let i=0;for(const r of t){const t=this.pluginManager.getPluginEntry(r);if(void 0!==t&&t.instance&&(n||t.enabled===e))for(const e of $e(t.instance))"function"==typeof t.instance[e]&&"constructor"!==e&&(s[e]=!0);i++;}if(0===i)for(const t of this.pluginManager.getPluginMapValues())if(t.instance&&(n||t.enabled===e))for(const e of $e(t.instance))"function"==typeof t.instance[e]&&"constructor"!==e&&(s[e]=!0);return Object.keys(s).sort()}hasMethod({method:e,plugins:t=[]}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if("string"!=typeof t&&!oe(t))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof t){const n=this.pluginManager.getPluginEntry(t);return void 0!==n&&"function"==typeof n.instance[e]}let n=0;for(const s of t){const t=this.pluginManager.getPluginEntry(s);if(void 0!==t&&"function"!=typeof t.instance[e])return !1;n++;}if(0===n)for(const t of this.pluginManager.getPluginMapValues())if("function"!=typeof t.instance[e])return !1;return !0}invoke({method:e,args:t,plugins:n}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if(void 0!==t&&!Array.isArray(t))throw new TypeError("'args' is not an array.");if(void 0===n&&(n=this.pluginManager.getPluginMapKeys()),"string"!=typeof n&&!oe(n))throw new TypeError("'plugins' is not a string or iterable.");let s=!1,i=!1;const r=Array.isArray(t);if("string"==typeof n){const o=this.pluginManager.getPluginEntry(n);void 0!==o&&o.enabled&&o.instance&&(i=!0,"function"==typeof o.instance[e]&&(r?o.instance[e](...t):o.instance[e](),s=!0));}else for(const o of n){const n=this.pluginManager.getPluginEntry(o);void 0!==n&&n.enabled&&n.instance&&(i=!0,"function"==typeof n.instance[e]&&(r?n.instance[e](...t):n.instance[e](),s=!0));}if(this.options.throwNoPlugin&&!i)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!s)throw new Error(`PluginManager failed to invoke '${e}'.`)}async invokeAsync({method:e,args:t,plugins:n}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if(void 0!==t&&!Array.isArray(t))throw new TypeError("'args' is not an array.");if(void 0===n&&(n=this.pluginManager.getPluginMapKeys()),"string"!=typeof n&&!oe(n))throw new TypeError("'plugins' is not a string or iterable.");let s,i=!1,r=!1;const o=[],a=Array.isArray(t);if("string"==typeof n){const h=this.pluginManager.getPluginEntry(n);void 0!==h&&h.enabled&&h.instance&&(r=!0,"function"==typeof h.instance[e]&&(s=a?h.instance[e](...t):h.instance[e](),void 0!==s&&o.push(s),i=!0));}else for(const h of n){const n=this.pluginManager.getPluginEntry(h);void 0!==n&&n.enabled&&n.instance&&(r=!0,"function"==typeof n.instance[e]&&(s=a?n.instance[e](...t):n.instance[e](),void 0!==s&&o.push(s),i=!0));}if(this.options.throwNoPlugin&&!r)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!i)throw new Error(`PluginManager failed to invoke '${e}'.`);return o.length>1?Promise.all(o).then((e=>{const t=e.filter((e=>void 0!==e));switch(t.length){case 0:return;case 1:return t[0];default:return t}})):s}async invokeAsyncEvent({method:e,copyProps:t={},passthruProps:n={},plugins:s}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return ce({method:e,manager:this.pluginManager,copyProps:t,passthruProps:n,plugins:s})}invokeSync({method:e,args:t,plugins:n}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if(void 0!==t&&!Array.isArray(t))throw new TypeError("'args' is not an array.");if(void 0===n&&(n=this.pluginManager.getPluginMapKeys()),"string"!=typeof n&&!oe(n))throw new TypeError("'plugins' is not a string or iterable.");let s,i=!1,r=!1;const o=[],a=Array.isArray(t);if("string"==typeof n){const h=this.pluginManager.getPluginEntry(n);void 0!==h&&h.enabled&&h.instance&&(r=!0,"function"==typeof h.instance[e]&&(s=a?h.instance[e](...t):h.instance[e](),void 0!==s&&o.push(s),i=!0));}else for(const h of n){const n=this.pluginManager.getPluginEntry(h);void 0!==n&&n.enabled&&n.instance&&(r=!0,"function"==typeof n.instance[e]&&(s=a?n.instance[e](...t):n.instance[e](),void 0!==s&&o.push(s),i=!0));}if(this.options.throwNoPlugin&&!r)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!i)throw new Error(`PluginManager failed to invoke '${e}'.`);return o.length>1?o:s}invokeSyncEvent({method:e,copyProps:t={},passthruProps:n={},plugins:s}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return function({method:e,manager:t,copyProps:n={},passthruProps:s={},plugins:i,options:r,errorCheck:o=!0}){if("string"!=typeof e)throw new TypeError("'method' is not a string.");if("object"!=typeof s)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof n)throw new TypeError("'copyProps' is not an object.");if(void 0===r&&(r=t.getOptions()),void 0===i&&(i=t.getPluginMapKeys()),"string"!=typeof i&&!oe(i))throw new TypeError("'plugins' is not a string or iterable.");let a=0;const h=[];let l=!1,c=!1;const u=new le(n,s);if("string"==typeof i){const n=t.getPluginEntry(i);void 0!==n&&n.enabled&&n.instance&&(c=!0,"function"==typeof n.instance[e]&&(u.eventbus=n.eventbusProxy,u.pluginName=n.name,u.pluginOptions=n.data.plugin.options,n.instance[e](u),l=!0,a++,h.push(n.name)));}else for(const n of i){const s=t.getPluginEntry(n);void 0!==s&&s.enabled&&s.instance&&(c=!0,"function"==typeof s.instance[e]&&(u.eventbus=s.eventbusProxy,u.pluginName=s.name,u.pluginOptions=s.data.plugin.options,s.instance[e](u),l=!0,a++,h.push(s.name)));}if(o&&r.throwNoPlugin&&!c)throw new Error("PluginManager failed to find any target plugins.");if(o&&r.throwNoMethod&&!l)throw new Error(`PluginManager failed to invoke '${e}'.`);return u.data.$$plugin_invoke_count=a,u.data.$$plugin_invoke_names=h,u.data}({method:e,manager:this.pluginManager,copyProps:t,passthruProps:n,plugins:s})}setEventbus({oldEventbus:e,newEventbus:t,oldPrepend:n,newPrepend:s}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");null!=e&&(e.off(`${n}:async:invoke`,this.invokeAsync,this),e.off(`${n}:async:invoke:event`,this.invokeAsyncEvent,this),e.off(`${n}:get:method:names`,this.getMethodNames,this),e.off(`${n}:has:method`,this.hasMethod,this),e.off(`${n}:invoke`,this.invoke,this),e.off(`${n}:sync:invoke`,this.invokeSync,this),e.off(`${n}:sync:invoke:event`,this.invokeSyncEvent,this)),null!=t&&(t.on(`${s}:async:invoke`,this.invokeAsync,this,{guard:!0}),t.on(`${s}:async:invoke:event`,this.invokeAsyncEvent,this,{guard:!0}),t.on(`${s}:get:method:names`,this.getMethodNames,this,{guard:!0}),t.on(`${s}:has:method`,this.hasMethod,this,{guard:!0}),t.on(`${s}:invoke`,this.invoke,this,{guard:!0}),t.on(`${s}:sync:invoke`,this.invokeSync,this,{guard:!0}),t.on(`${s}:sync:invoke:event`,this.invokeSyncEvent,this,{guard:!0}));}setOptions(e){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.")}}const $e=e=>{const t=[];do{Object.getOwnPropertyNames(e).forEach((e=>{-1===t.indexOf(e)&&t.push(e);})),e=Object.getPrototypeOf(e);}while(null!=e&&e!==Object.prototype);return t};

export { v as Eventbus, I as EventbusProxy, B as EventbusSecure, Me as PluginInvokeSupport, ke as PluginManager, ge as escapeTarget, q as eventbus, pe as isValidConfig, F as pluginEventbus, H as testEventbus };
//# sourceMappingURL=index.js.map
