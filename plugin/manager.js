function e(h,p){return function(h,p){return p.get?p.get.call(h):p.value}(h,n(h,p,"get"))}function t(h,p,y){return function(h,p,y){if(p.set)p.set.call(h,y);else{if(!p.writable)throw new TypeError("attempted to set read only private field");p.value=y}}(h,n(h,p,"set"),y),y}function n(h,p,y){if(!p.has(h))throw new TypeError("attempted to "+y+" private field on non-instance");return p.get(h)}function s(h,p,y){!function(h,p){if(p.has(h))throw new TypeError("Cannot initialize the same private elements twice on an object")}(h,p),p.set(h,y)}function i(h,p){return function(h,p){return p.get?p.get.call(h):p.value}(h,o(h,p,"get"))}function r(h,p,y){return function(h,p,y){if(p.set)p.set.call(h,y);else{if(!p.writable)throw new TypeError("attempted to set read only private field");p.value=y}}(h,o(h,p,"set"),y),y}function o(h,p,y){if(!p.has(h))throw new TypeError("attempted to "+y+" private field on non-instance");return p.get(h)}function a(h,p,y){!function(h,p){if(p.has(h))throw new TypeError("Cannot initialize the same private elements twice on an object")}(h,p),p.set(h,y)}const h=/\s+/;function l(p,y,w,b,E){let m,P=0;if(w&&"object"==typeof w){void 0!==b&&"context"in E&&void 0===E.context&&(E.context=b);for(m=f(w);P<m.length;P++)y=l(p,y,m[P],w[m[P]],E)}else if(w&&h.test(w))for(m=w.split(h);P<m.length;P++)y=p(y,m[P],b,E);else y=p(y,w,b,E);return y}function c(h){const p=h.name;return""!==p?`[${p}] `:""}function u(h,p,y,w){const b=w.events;if(b){const y=b[p];if(Array.isArray(y))for(const p of y)p.options.guard&&(h.guard=!0),p.options.type>h.type&&(h.type=p.options.type)}return h}const f=h=>null===h||"object"!=typeof h?[]:Object.keys(h);function d(h,p,y,w){const b=w.after,E=w.count+1;if(y){const w=h[p]=g(E,(function(){return y.apply(this,arguments)}),(()=>{b(p,w)}));w._callback=y}return h}const g=function(h,p,y){let w;return function(...b){return--h>0&&(w=p.apply(this,b)),h<=1&&(y&&y.apply(this,b),y=void 0,p=void 0),w}};var p=new WeakMap,y=new WeakMap;class v{constructor(h=""){if(a(this,p,{writable:!0,value:""}),a(this,y,{writable:!0,value:void 0}),"string"!=typeof h)throw new TypeError("'name' is not a string");r(this,p,h),this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0}before(h,p,y,w,b={}){if(!Number.isInteger(h))throw new TypeError("'count' is not an integer");const E={};if(this.isGuarded(p,E))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(E.names)}`),this;const m=l(d,{},p,y,{count:h,after:this.off.bind(this)});return"string"==typeof p&&null==w&&(y=void 0),this.on(m,y,w,b)}*entries(h){if(void 0!==h&&!(h instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,y))if(h){for(const p in i(this,y))if(h.test(p))for(const h of i(this,y)[p])yield[p,h.callback,h.context,JSON.parse(JSON.stringify(h.options))]}else for(const h in i(this,y))for(const p of i(this,y)[h])yield[h,p.callback,p.context,JSON.parse(JSON.stringify(p.options))]}get eventCount(){return i(this,y)?Object.keys(i(this,y)).length:0}get callbackCount(){if(!i(this,y))return 0;let h=0;for(const p in i(this,y))h+=i(this,y)[p].length;return h}getOptions(h){const p=l(u,{guard:!1,type:0},h,void 0,{events:i(this,y)});let w;switch(p.type){case 1:w="sync";break;case 2:w="async"}return{guard:p.guard,type:w}}getType(h){switch(l(M,{type:0},h,void 0,{events:i(this,y)}).type){case 1:return"sync";case 2:return"async";default:return}}isGuarded(h,p={}){return p.names=[],p.guarded=!1,l($,p,h,void 0,{events:i(this,y)}).guarded}*keys(h){if(void 0!==h&&!(h instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,y))if(h)for(const p in i(this,y))h.test(p)&&(yield p);else for(const h in i(this,y))yield h}*keysWithOptions(h){if(void 0!==h&&!(h instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,y))if(h)for(const p in i(this,y))h.test(p)&&(yield[p,this.getOptions(p)]);else for(const h in i(this,y))yield[h,this.getOptions(h)]}get name(){return i(this,p)}listenTo(h,p,y){if(!h)return this;const b={};if(j(h,p,b))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(b.names)}`),this;const E=h._listenId||(h._listenId=C("l")),m=this._listeningTo||(this._listeningTo={});let P=w=m[E];P||(this._listenId||(this._listenId=C("l")),P=w=m[E]=new x(this,h));const T=J(h,p,y,this);if(w=void 0,T)throw T;return P.interop&&P.on(p,y),this}listenToBefore(h,p,y,w){if(!Number.isInteger(h))throw new TypeError("'count' is not an integer");const b=l(d,{},y,w,{count:h,after:this.stopListening.bind(this,p)});return this.listenTo(p,b)}listenToOnce(h,p,y){const w=l(d,{},p,y,{count:1,after:this.stopListening.bind(this,h)});return this.listenTo(h,w)}off(h,p,w){return i(this,y)?(r(this,y,l(O,i(this,y),h,p,{context:w,listeners:this._listeners})),this):this}on(h,p,b,E={}){if(null==E||E.constructor!==Object)throw new TypeError("'options' must be an object literal.");const m={};return this.isGuarded(h,m)?(console.warn(`@typhonjs-plugin/eventbus ${c(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(m.names)}`),this):(r(this,y,l(R,i(this,y)||{},h,p,{context:b,ctx:this,options:E,listening:w})),w&&((this._listeners||(this._listeners={}))[w.id]=w,w.interop=!1),this)}once(h,p,y,w={}){const b={};if(this.isGuarded(h,b))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(b.names)}`),this;const E=l(d,{},h,p,{count:1,after:this.off.bind(this)});return"string"==typeof h&&null==y&&(p=void 0),this.on(E,p,y,w)}stopListening(h,p,y){const w=this._listeningTo;if(!w)return this;const b=h?[h._listenId]:f(w);for(let h=0;h<b.length;h++){const E=w[b[h]];if(!E)break;E.obj.off(p,y,this),E.interop&&E.off(p,y)}return this}trigger(h,...p){return i(this,y)?(S(D,N,i(this,y),h,void 0,p),this):this}async triggerAsync(h,...p){if(!i(this,y))return;const w=S(D,_,i(this,y),h,void 0,p);return void 0!==w?Array.isArray(w)?Promise.all(w).then((h=>{let p=[];for(const y of h)Array.isArray(y)?p=p.concat(y):void 0!==y&&p.push(y);return p.length>1?p:1===p.length?p[0]:void 0})):w:void 0}triggerDefer(h,...p){return setTimeout((()=>{this.trigger(h,...p)}),0),this}triggerSync(h,...p){if(i(this,y))return S(D,A,i(this,y),h,void 0,p)}}let w;var b=new WeakMap,E=new WeakMap,m=new WeakMap,P=new WeakMap,T=new WeakMap,k=new WeakMap;class x{constructor(h,p){a(this,b,{writable:!0,value:void 0}),a(this,E,{writable:!0,value:void 0}),a(this,m,{writable:!0,value:void 0}),a(this,P,{writable:!0,value:void 0}),a(this,T,{writable:!0,value:void 0}),a(this,k,{writable:!0,value:0}),r(this,E,h._listenId),r(this,m,h),r(this,P,p),r(this,T,!0)}cleanup(){delete i(this,m)._listeningTo[i(this,P)._listenId],i(this,T)||delete i(this,P)._listeners[i(this,E)]}get id(){return i(this,E)}get interop(){return i(this,T)}get obj(){return i(this,P)}incrementCount(){r(this,k,+i(this,k)+1)}on(h,p,y){return r(this,b,l(R,i(this,b)||{},h,p,{context:y,ctx:this,options:{},listening:this})),this}off(h,p){let y;i(this,T)?(r(this,b,l(O,i(this,b),h,p,{context:void 0,listeners:void 0})),y=!i(this,b)):(r(this,k,+i(this,k)-1),y=0===i(this,k)),y&&this.cleanup()}set interop(h){if("boolean"!=typeof h)throw new TypeError("'value' is not a boolean");r(this,T,h)}}const M=(h,p,y,w)=>{const b=w.events;if(b){const y=b[p];if(Array.isArray(y))for(const p of y)p.options.type>h.type&&(h.type=p.options.type)}return h},$=(h,p,y,w)=>{const b=w.events;if(b){const y=b[p];if(Array.isArray(y))for(const w of y)if(w.options.guard)return h.names.push(p),h.guarded=!0,h}return h},O=(h,p,y,w)=>{if(!h)return;const b=w.context,E=w.listeners;let m,P=0;if(p||b||y){for(m=p?[p]:f(h);P<m.length;P++){const w=h[p=m[P]];if(!w)break;const E=[];for(let h=0;h<w.length;h++){const m=w[h];if(y&&y!==m.callback&&y!==m.callback._callback||b&&b!==m.context)E.push(m);else{const h=m.listening;h&&h.off(p,y)}}E.length?h[p]=E:delete h[p]}return h}for(m=f(E);P<m.length;P++)E[m[P]].cleanup()},R=(h,p,y,w)=>{if(y){const b=h[p]||(h[p]=[]),E=w.context,m=w.ctx,P=w.listening,T=JSON.parse(JSON.stringify(w.options));switch(T.guard="boolean"==typeof T.guard&&T.guard,T.type){case"sync":T.type=1;break;case"async":T.type=2;break;default:T.type=0}P&&P.incrementCount(),b.push({callback:y,context:E,ctx:E||m,options:T,listening:P})}return h},S=(p,y,w,b,E,m)=>{let P,T,k=0;if(b&&h.test(b))for(T=b.split(h);k<T.length;k++){const h=p(y,w,T[k],E,m),b=Array.isArray(P)?2:void 0!==P?1:0;if(Array.isArray(h))switch(b){case 0:P=h;break;case 1:P=[P].concat(h);break;case 2:P=P.concat(h)}else if(void 0!==h)switch(b){case 0:P=h;break;case 1:{const p=[P];p.push(h),P=p;break}case 2:P.push(h)}}else P=p(y,w,b,E,m);return P},D=(h,p,y,w,b)=>{let E;if(p){const w=p[y];let m=p.all;w&&m&&(m=m.slice()),w&&(E=h(w,b)),m&&(E=h(m,[y].concat(b)))}return E},N=(h,p)=>{let y,w=-1;const b=p[0],E=p[1],m=p[2],P=h.length;switch(p.length){case 0:for(;++w<P;)(y=h[w]).callback.call(y.ctx);return;case 1:for(;++w<P;)(y=h[w]).callback.call(y.ctx,b);return;case 2:for(;++w<P;)(y=h[w]).callback.call(y.ctx,b,E);return;case 3:for(;++w<P;)(y=h[w]).callback.call(y.ctx,b,E,m);return;default:for(;++w<P;)(y=h[w]).callback.apply(y.ctx,p);return}},_=async(h,p)=>{let y,w=-1;const b=p[0],E=p[1],m=p[2],P=h.length,T=[];switch(p.length){case 0:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx);void 0!==p&&T.push(p)}break;case 1:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx,b);void 0!==p&&T.push(p)}break;case 2:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx,b,E);void 0!==p&&T.push(p)}break;case 3:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx,b,E,m);void 0!==p&&T.push(p)}break;default:for(;++w<P;){const b=(y=h[w]).callback.apply(y.ctx,p);void 0!==b&&T.push(b)}}return T.length>1?Promise.all(T).then((h=>{const p=h.filter((h=>void 0!==h));switch(p.length){case 0:return;case 1:return p[0];default:return p}})):1===T.length?T[0]:void 0},A=(h,p)=>{let y,w=-1;const b=p[0],E=p[1],m=p[2],P=h.length,T=[];switch(p.length){case 0:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx);void 0!==p&&T.push(p)}break;case 1:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx,b);void 0!==p&&T.push(p)}break;case 2:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx,b,E);void 0!==p&&T.push(p)}break;case 3:for(;++w<P;){const p=(y=h[w]).callback.call(y.ctx,b,E,m);void 0!==p&&T.push(p)}break;default:for(;++w<P;){const b=(y=h[w]).callback.apply(y.ctx,p);void 0!==b&&T.push(b)}}return T.length>1?T:1===T.length?T[0]:void 0},j=(h,p,y={})=>{let w=!1;try{const b=h.isGuarded(p,y);"boolean"==typeof b&&(w=b)}catch(h){w=!1,y.names=[],y.guarded=!1}return w},J=(h,p,y,w)=>{try{h.on(p,y,w)}catch(h){return h}};let W=0;const C=(h="")=>{const p=""+ ++W;return h?`${h}${p}`:p};var L=new WeakMap,U=new WeakMap;class I{constructor(h){a(this,L,{writable:!0,value:void 0}),a(this,U,{writable:!0,value:void 0}),r(this,L,h),Object.seal(this)}before(h,p,y,w,b={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!Number.isInteger(h))throw new TypeError("'count' is not an integer");const E={};if(i(this,L).isGuarded(p,E))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(E.names)}`),this;const m=l(d,{},p,y,{count:h,after:this.off.bind(this)});return"string"==typeof p&&null==w&&(y=void 0),this.on(m,y,w,b)}createProxy(){return new I(i(this,L))}destroy(){null!==i(this,L)&&this.off(),r(this,U,void 0),r(this,L,null)}*entries(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const p of i(this,L).entries(h))yield p}get eventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).eventCount}get callbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).callbackCount}*keys(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const p of i(this,L).keys(h))yield p}*keysWithOptions(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const p of i(this,L).keysWithOptions(h))yield p}get isDestroyed(){return null===i(this,L)}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return`proxy-${i(this,L).name}`}get proxyEventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,U)?Object.keys(i(this,U)).length:0}get proxyCallbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!i(this,U))return 0;let h=0;for(const p in i(this,U))h+=i(this,U)[p].length;return h}getOptions(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).getOptions(h)}getType(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).getType(h)}isGuarded(h,p={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).isGuarded(h,p)}off(h,p,y){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return r(this,U,l(K,i(this,U)||{},h,p,{context:y,eventbus:i(this,L)})),this}on(h,p,y,w={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(null==w||w.constructor!==Object)throw new TypeError("'options' must be an object literal.");const b={};if(i(this,L).isGuarded(h,b))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(b.names)}`),this;const E={context:y,ctx:this,options:w};return r(this,U,l(G,i(this,U)||{},h,p,E)),i(this,L).on(h,p,E.ctx,w),this}once(h,p,y,w={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");const b={};if(i(this,L).isGuarded(h,b))return console.warn(`@typhonjs-plugin/eventbus ${c(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(b.names)}`),this;const E=l(d,{},h,p,{count:1,after:this.off.bind(this)});return"string"==typeof h&&null==y&&(p=void 0),this.on(E,p,y,w)}*proxyEntries(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==h&&!(h instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,U))if(h){for(const p in i(this,U))if(h.test(p))for(const h of i(this,U)[p])yield[p,h.callback,h.context,JSON.parse(JSON.stringify(h.options))]}else for(const h in i(this,U))for(const p of i(this,U)[h])yield[h,p.callback,p.context,JSON.parse(JSON.stringify(p.options))]}*proxyKeys(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==h&&!(h instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,U))if(h)for(const p in i(this,U))h.test(p)&&(yield p);else for(const h in i(this,U))yield h}*proxyKeysWithOptions(h){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==h&&!(h instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(i(this,U))if(h)for(const p in i(this,U))h.test(p)&&(yield[p,i(this,L).getOptions(p)]);else for(const h in i(this,U))yield[h,i(this,L).getOptions(h)]}trigger(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).trigger(h,...p),this}triggerAsync(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).triggerAsync(h,...p)}triggerDefer(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).triggerDefer(h,...p),this}triggerSync(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i(this,L).triggerSync(h,...p)}}const K=(h,p,y,w)=>{if(!h)return;const b=w.context,E=w.eventbus,m=p?[p]:f(h);for(let w=0;w<m.length;w++){const P=h[p=m[w]];if(!P)break;const T=[];for(let h=0;h<P.length;h++){const w=P[h];y&&y!==w.callback&&y!==w.callback._callback||b&&b!==w.context?T.push(w):E.off(p,w.callback||w.callback._callback,w.context||w.ctx)}T.length?h[p]=T:delete h[p]}return h},G=(h,p,y,w)=>{if(y){const b=h[p]||(h[p]=[]),E=w.context,m=w.ctx,P=JSON.parse(JSON.stringify(w.options));switch(P.guard=void 0!==P.guard&&"boolean"==typeof P.guard&&P.guard,P.type){case"sync":P.type=1;break;case"async":P.type=2;break;default:P.type=0}w.ctx=E||m,b.push({callback:y,context:E,ctx:w.ctx,options:P})}return h};var z=new WeakMap,V=new WeakMap;class B{constructor(){a(this,z,{writable:!0,value:void 0}),a(this,V,{writable:!0,value:void 0})}static initialize(h,p){if(void 0!==p&&"string"!=typeof p)throw new TypeError("'name' is not a string.");const y=new B;return r(y,z,h),r(y,V,void 0===p?h.name:p),Object.seal(y),{destroy:function(){y.isDestroyed||(r(y,z,null),this&&(this.eventbusSecure=void 0))},setEventbus:function(h,p){if(void 0!==p&&"string"!=typeof p)throw new TypeError("'name' is not a string.");y.isDestroyed||(void 0===p&&i(y,V)===i(y,z).name?r(y,V,h.name):void 0!==p&&r(y,V,p),r(y,z,h))},eventbusSecure:y}}*keys(h){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");for(const p of i(this,z).keys(h))yield p}*keysWithOptions(h){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");for(const p of i(this,z).keysWithOptions(h))yield p}get isDestroyed(){return null===i(this,z)}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,V)}getOptions(h){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).getOptions(h)}getType(h){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).getType(h)}trigger(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).trigger(h,...p),this}triggerAsync(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).triggerAsync(h,...p)}triggerDefer(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).triggerDefer(h,...p),this}triggerSync(h,...p){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return i(this,z).triggerSync(h,...p)}}const q=new v("mainEventbus"),F=new v("pluginEventbus"),H=new v("testEventbus"),Q=/^(https?:\/\/|file:\/\/)/;var X=new WeakMap,Y=new WeakMap,Z=new WeakMap,ee=new WeakMap,te=new WeakMap,ne=new WeakMap,se=new WeakMap;class ie{constructor(h,p,y,w){s(this,X,{writable:!0,value:void 0}),s(this,Y,{writable:!0,value:void 0}),s(this,Z,{writable:!0,value:void 0}),s(this,ee,{writable:!0,value:void 0}),s(this,te,{writable:!0,value:void 0}),s(this,ne,{writable:!0,value:void 0}),s(this,se,{writable:!0,value:void 0}),t(this,X,p),t(this,Y,!0),t(this,Z,h),t(this,te,y),t(this,ne,w)}get data(){return e(this,X)}get enabled(){return e(this,Y)}get importmeta(){return e(this,ee)}reset(){try{t(this,se,void 0),t(this,ee,void 0),delete e(this,te)._eventbus}catch(h){}}set enabled(h){if(t(this,Y,h),h){if(void 0!==e(this,ne)&&Array.isArray(e(this,se))){for(const h of e(this,se))e(this,ne).on(...h);t(this,se,void 0)}}else void 0!==e(this,ne)&&(t(this,se,Array.from(e(this,ne).proxyEntries())),e(this,ne).off())}get eventbusProxy(){return e(this,ne)}get instance(){return e(this,te)}get name(){return e(this,Z)}set eventbusProxy(h){t(this,ne,h)}set importmeta(h){t(this,ee,h)}set instance(h){t(this,te,h)}}function re(h,p=[]){if("object"!=typeof h)throw new TypeError("'data' is not an 'object'.");if(!Array.isArray(p))throw new TypeError("'skipFreezeKeys' is not an 'array'.");return he(h,p)}function oe(h){return null!=h&&"object"==typeof h&&"function"==typeof h[Symbol.iterator]}function ae(h){return null!==h&&"object"==typeof h}function he(h,p){if(Array.isArray(h))for(let y=0;y<h.length;y++)he(h[y],p);else if("object"==typeof h)for(const y in h)h.hasOwnProperty(y)&&!p.includes(y)&&he(h[y],p);return Object.freeze(h)}class le{constructor(h={},p={}){this.data=Object.assign(JSON.parse(JSON.stringify(h)),p),this.eventbus=void 0,this.pluginName=void 0,this.pluginOptions=void 0}}async function ce({method:h,manager:p,copyProps:y={},passthruProps:w={},plugins:b,options:E,errorCheck:m=!0}){if("string"!=typeof h)throw new TypeError("'method' is not a string.");if("object"!=typeof w)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof y)throw new TypeError("'copyProps' is not an object.");if(void 0===E&&(E=p.getOptions()),void 0===b&&(b=p.getPluginMapKeys()),"string"!=typeof b&&!oe(b))throw new TypeError("'plugins' is not a string or iterable.");let P=0;const T=[];let k=!1,W=!1;const L=new le(y,w),U=[];if("string"==typeof b){const y=p.getPluginEntry(b);if(void 0!==y&&y.enabled&&y.instance&&(W=!0,"function"==typeof y.instance[h])){L.eventbus=y.eventbusProxy,L.pluginName=y.name,L.pluginOptions=y.data.plugin.options;const p=y.instance[h](L);null!=p&&U.push(p),k=!0,P++,T.push(y.name)}}else for(const y of b){const w=p.getPluginEntry(y);if(void 0!==w&&w.enabled&&w.instance&&(W=!0,"function"==typeof w.instance[h])){L.eventbus=w.eventbusProxy,L.pluginName=w.name,L.pluginOptions=w.data.plugin.options;const p=w.instance[h](L);null!=p&&U.push(p),k=!0,P++,T.push(w.name)}}if(m&&E.throwNoPlugin&&!W)throw new Error("PluginManager failed to find any target plugins.");if(m&&E.throwNoMethod&&!k)throw new Error(`PluginManager failed to invoke '${h}'.`);return L.data.$$plugin_invoke_count=P,L.data.$$plugin_invoke_names=T,await Promise.all(U),L.data}const ue=/^([.]{1,2}[\\|/])+/g,fe=/[\\]/g,de=/^(https?|file):/g;function ge(h){let p=h;return h instanceof URL?p=h.pathname:h.match(de)&&(p=new URL(h).pathname),p=p.replace(ue,""),p=p.replace(fe,"\\\\"),p}function pe(h){return"object"==typeof h&&"string"==typeof h.name&&(void 0===h.target||"string"==typeof h.target||h.target instanceof URL)&&(void 0===h.options||"object"==typeof h.options)}function ye(h){return"function"==typeof h.onPluginLoad?h:h.default?h.default:h}var ve=new WeakMap,we=new WeakMap,be=new WeakMap,Ee=new WeakMap,me=new WeakMap,Pe=new WeakMap,Te=new WeakMap;class ke{constructor(h={}){if(s(this,ve,{writable:!0,value:null}),s(this,we,{writable:!0,value:[]}),s(this,be,{writable:!0,value:[]}),s(this,Ee,{writable:!0,value:{noEventAdd:!1,noEventDestroy:!0,noEventRemoval:!1,noEventSetEnabled:!0,noEventSetOptions:!0,throwNoMethod:!1,throwNoPlugin:!1}}),s(this,me,{writable:!0,value:new Set}),s(this,Pe,{writable:!0,value:new Map}),s(this,Te,{writable:!0,value:[]}),!ae(h))throw new TypeError("'options' is not an object.");if(void 0!==h.eventbus&&!ae(h.eventbus))throw new TypeError("'options.eventbus' is not an Eventbus.");if(void 0!==h.eventPrepend&&"string"!=typeof h.eventPrepend)throw new TypeError("'options.eventPrepend' is not a string.");if(void 0!==h.manager&&!ae(h.manager))throw new TypeError("'options.manager' is not an object.");if(void 0!==h.PluginSupport&&"function"!=typeof h.PluginSupport&&!oe(h.PluginSupport))throw new TypeError("'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.");if(oe(h.PluginSupport))for(const p of h.PluginSupport)e(this,Te).push(new p(this));else void 0!==h.PluginSupport&&e(this,Te).push(new h.PluginSupport(this));this.setOptions(h.manager||{}),this.setEventbus({eventbus:void 0!==h.eventbus?h.eventbus:new v,eventPrepend:h.eventPrepend})}async add(h,p){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("object"!=typeof h)throw new TypeError("'pluginConfig' is not an object.");if("string"!=typeof h.name)throw new TypeError(`'pluginConfig.name' is not a string for entry:\n${JSON.stringify(h,null,3)}`);if(void 0!==h.target&&"string"!=typeof h.target&&!(h.target instanceof URL))throw new TypeError(`'pluginConfig.target' is not a string or URL for entry:\n${JSON.stringify(h,null,3)}`);if(void 0!==h.options&&"object"!=typeof h.options)throw new TypeError(`'pluginConfig.options' is not an object for entry:\n${JSON.stringify(h,null,3)}`);if(void 0!==p&&"object"!=typeof p)throw new TypeError(`'moduleData' is not an object for entry:\n${JSON.stringify(h,null,3)}`);if(e(this,Pe).has(h.name))throw new Error(`A plugin already exists with name: ${h.name} for entry:\n${JSON.stringify(h,null,3)}`);if(e(this,me).has(h.name))throw new Error(`A plugin is already being loaded with name: ${h.name} for entry:\n${JSON.stringify(h,null,3)}`);let y,w,b;if(e(this,me).add(h.name),"object"==typeof h.instance||"function"==typeof h.instance)y=h.instance,w=h.name,b="instance";else{w=h.target||h.name;try{const h=await class{static async load({modulepath:h,resolveModule:p}={}){if(!(h instanceof URL)&&"string"!=typeof h)throw new TypeError("'modulepath' is not a string or URL");if(void 0!==p&&"function"!=typeof p)throw new TypeError("'resolveModule' is not a function");const y=await import(h),w=h instanceof URL?h.toString():h,b="import-"+(h instanceof URL||"string"==typeof h&&h.match(Q)?"url":"path");return{filepath:w,instance:void 0!==p?p(y):y,isESM:!0,loadpath:w,module:y,modulepath:h,type:b}}}.load({modulepath:w,resolveModule:ye});null!==e(this,ve)&&e(this,ve).trigger("log:debug",`@typhonjs-plugin/manager - ${h.isESM?"import":"require"}: ${h.loadpath}`),y=h.instance,b=h.type}catch(p){throw e(this,me).delete(h.name),new Error(`@typhonjs-plugin/manager - Could not load target: ${w}\n\nPluginConfig:\n${JSON.stringify(h,null,3)}\n\n${p}`)}}w instanceof URL&&(w=w.toString());const E=JSON.parse(JSON.stringify({manager:{eventPrepend:this._eventPrepend,scopedName:`${this._eventPrepend}:${h.name}`},module:p||{},plugin:{name:h.name,target:w,targetEscaped:ge(w),type:b,options:h.options||{}}}));re(E,["manager"]);const m=null!==e(this,ve)&&void 0!==e(this,ve)?new I(e(this,ve)):void 0,P=new ie(h.name,E,y,m);e(this,Pe).set(h.name,P),e(this,me).delete(h.name);const T=await ce({method:"onPluginLoad",manager:this,plugins:h.name,errorCheck:!1});return"object"==typeof T.importmeta&&(P.importmeta=T.importmeta,"object"==typeof T.importmeta.hot&&"function"==typeof T.importmeta.hot.accept&&T.importmeta.hot.accept((({module:p})=>{this.reload({plugin:h.name,instance:ye(p)})}))),e(this,ve)&&await e(this,ve).triggerAsync("typhonjs:plugin:manager:plugin:added",E),E}async addAll(h,p){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!oe(h))throw new TypeError("'pluginConfigs' is not iterable.");const y=[];for(const w of h){const h=await this.add(w,p);h&&y.push(h)}return y}async _addEventbus(h,p){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventAdd?void 0:this.add(h,p)}async _addAllEventbus(h,p){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventAdd?[]:this.addAll(h,p)}createEventbusProxy(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(null===e(this,ve))throw new ReferenceError("No eventbus assigned to plugin manager.");const h=new I(e(this,ve));return e(this,we).push(h),h}createEventbusSecure(h){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(null===e(this,ve))throw new ReferenceError("No eventbus assigned to plugin manager.");const p=B.initialize(e(this,ve),h);return e(this,be).push(p),p.eventbusSecure}async destroy(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");const h=await this.removeAll();for(const h of e(this,be))h.destroy();t(this,be,[]);for(const h of e(this,we))h.destroy();t(this,we,[]),null!==e(this,ve)&&void 0!==e(this,ve)&&(e(this,ve).off(`${this._eventPrepend}:async:add`,this._addEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:add:all`,this._addAllEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:destroy:manager`,this._destroyEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:remove`,this._removeEventbus,this),e(this,ve).off(`${this._eventPrepend}:async:remove:all`,this._removeAllEventbus,this),e(this,ve).off(`${this._eventPrepend}:get:enabled`,this.getEnabled,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:by:event`,this.getPluginByEvent,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:data`,this.getPluginData,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:events`,this.getPluginEvents,this),e(this,ve).off(`${this._eventPrepend}:get:plugin:names`,this.getPluginNames,this),e(this,ve).off(`${this._eventPrepend}:get:options`,this.getOptions,this),e(this,ve).off(`${this._eventPrepend}:has:plugin`,this.hasPlugins,this),e(this,ve).off(`${this._eventPrepend}:is:valid:config`,this.isValidConfig,this),e(this,ve).off(`${this._eventPrepend}:set:enabled`,this._setEnabledEventbus,this),e(this,ve).off(`${this._eventPrepend}:set:options`,this._setOptionsEventbus,this));for(const h of e(this,Te))await h.destroy({eventbus:e(this,ve),eventPrepend:this._eventPrepend});return t(this,Te,[]),t(this,Pe,null),t(this,ve,null),h}async _destroyEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventDestroy?[]:this.destroy()}get isDestroyed(){return null===e(this,Pe)||void 0===e(this,Pe)}getEnabled({plugins:h=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h&&!oe(h))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof h){const p=e(this,Pe).get(h);return void 0!==p&&p.enabled}const p=[];let y=0;for(const w of h){const h=e(this,Pe).get(w),b=void 0!==h;p.push({plugin:w,enabled:b&&h.enabled,loaded:b}),y++}if(0===y)for(const[h,y]of e(this,Pe).entries()){const w=void 0!==y;p.push({plugin:h,enabled:w&&y.enabled,loaded:w})}return p}getEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,ve)}getOptions(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return JSON.parse(JSON.stringify(e(this,Ee)))}getPluginByEvent({event:h}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h&&!(h instanceof RegExp))throw new TypeError("'event' is not a string or RegExp.");const p=this.getPluginEvents(),y=[];if("string"==typeof h)for(const w of p)w.events.includes(h)&&y.push(w.plugin);else for(const w of p)for(const p of w.events)if(h.test(p)){y.push(w.plugin);break}return y}getPluginData({plugins:h=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h&&!oe(h))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof h){const p=e(this,Pe).get(h);return void 0!==p?JSON.parse(JSON.stringify(p.data)):void 0}const p=[];let y=0;for(const w of h){const h=e(this,Pe).get(w);void 0!==h&&p.push(JSON.parse(JSON.stringify(h.data))),y++}if(0===y)for(const h of e(this,Pe).values())void 0!==h&&p.push(JSON.parse(JSON.stringify(h.data)));return p}getPluginEntry(h){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Pe).get(h)}getPluginEvents({plugins:h=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h&&!oe(h))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof h){const p=e(this,Pe).get(h);return void 0!==p&&p.eventbusProxy?Array.from(p.eventbusProxy.proxyKeys()).sort():[]}const p=[];let y=0;for(const w of h){const h=e(this,Pe).get(w);void 0!==h&&p.push({plugin:w,events:h.eventbusProxy?Array.from(h.eventbusProxy.proxyKeys()).sort():[]}),y++}if(0===y)for(const h of e(this,Pe).values())void 0!==h&&p.push({plugin:h.name,events:h.eventbusProxy?Array.from(h.eventbusProxy.proxyKeys()).sort():[]});return p}getPluginMapKeys(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Pe).keys()}getPluginMapValues(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Pe).values()}getPluginNames({enabled:h}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(void 0!==h&&"boolean"!=typeof h)throw new TypeError("'enabled' is not a boolean.");const p=void 0===h,y=[];for(const w of e(this,Pe).values())(p||w.enabled===h)&&y.push(w.name);return y.sort()}hasPlugins({plugins:h=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h&&!oe(h))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof h)return e(this,Pe).has(h);let p=0;for(const y of h){if(!e(this,Pe).has(y))return!1;p++}return 0!==p||0!==e(this,Pe).size}isValidConfig(h){return pe(h)}async reload({plugin:h,instance:p,silent:y=!1}){if("string"!=typeof h)throw new TypeError("'plugin' is not a string.");if(void 0!==p&&"object"!=typeof p)throw new TypeError("'instance' is not an object.");if("boolean"!=typeof y)throw new TypeError("'silent' is not a boolean.");const w=e(this,Pe).get(h);if(void 0===w)return!1;let b,E;try{b=(await ce({method:"onPluginUnload",manager:this,plugins:h,errorCheck:!1})).state}catch(h){E=h}w.reset(),w.eventbusProxy instanceof I&&w.eventbusProxy.off(),"object"==typeof p&&(w.instance=p);const m=await ce({method:"onPluginLoad",manager:this,plugins:h,passthruProps:{state:b},errorCheck:!1});try{e(this,ve)&&!y&&await e(this,ve).triggerAsync("typhonjs:plugin:manager:plugin:reloaded",JSON.parse(JSON.stringify(w.data)))}catch(h){void 0===E&&(E=h)}if("object"==typeof m.importmeta&&(w.importmeta=m.importmeta,"object"==typeof m.importmeta.hot&&"function"==typeof m.importmeta.hot.accept&&m.importmeta.hot.accept((({module:p})=>{this.reload({plugin:h,instance:ye(p)})}))),E)throw E;return!0}async remove({plugins:h}){var p=this;if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h&&!oe(h))throw new TypeError("'plugins' is not a string or iterable.");const s=async function(h){const y=[],w=h.name;try{await ce({method:"onPluginUnload",manager:p,plugins:w,errorCheck:!1})}catch(h){y.push(h)}h.reset(),h.eventbusProxy instanceof I&&h.eventbusProxy.destroy(),e(p,Pe).delete(w);try{e(p,ve)&&await e(p,ve).triggerAsync("typhonjs:plugin:manager:plugin:removed",JSON.parse(JSON.stringify(h.data)))}catch(h){y.push(h)}return{plugin:w,success:0===y.length,errors:y}},y=[];if("string"==typeof h){const p=e(this,Pe).get(h);void 0!==p&&y.push(await s(p))}else for(const p of h){const h=e(this,Pe).get(p);void 0!==h&&y.push(await s(h))}return y}async removeAll(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.remove({plugins:Array.from(e(this,Pe).keys())})}async _removeEventbus(h){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventRemoval?[]:this.remove(h)}async _removeAllEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,Ee).noEventRemoval?[]:this.removeAll()}setEnabled({enabled:h,plugins:p=[]}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof p&&!oe(p))throw new TypeError("'plugins' is not a string or iterable.");if("boolean"!=typeof h)throw new TypeError("'enabled' is not a boolean.");const s=p=>{void 0!==p&&(p.enabled=h,e(this,ve)&&e(this,ve).trigger("typhonjs:plugin:manager:plugin:enabled",Object.assign({enabled:h},JSON.parse(JSON.stringify(p.data)))))};"string"==typeof p&&s(e(this,Pe).get(p));let y=0;for(const h of p)s(e(this,Pe).get(h)),y++;if(0===y)for(const h of e(this,Pe).values())s(h)}_setEnabledEventbus(h){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");e(this,Ee).noEventSetEnabled||this.setEnabled(h)}async setEventbus({eventbus:h,eventPrepend:p="plugins"}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!ae(h))throw new TypeError("'eventbus' is not an Eventbus.");if("string"!=typeof p)throw new TypeError("'eventPrepend' is not a string.");if(h===e(this,ve))return;const y=this._eventPrepend;if(this._eventPrepend=p,e(this,Pe).size>0){await ce({method:"onPluginUnload",manager:this,errorCheck:!1});for(const y of e(this,Pe).values()){try{delete y.instance._eventbus}catch(h){}y.data.manager.eventPrepend=p,y.data.manager.scopedName=`${p}:${y.name}`,y.eventbusProxy instanceof I&&y.eventbusProxy.destroy(),y.eventbusProxy=new I(h),y.enabled&&await ce({method:"onPluginLoad",manager:this,plugins:y.name,errorCheck:!1})}}null!==e(this,ve)&&(e(this,ve).off(`${y}:async:add`,this._addEventbus,this),e(this,ve).off(`${y}:async:add:all`,this._addAllEventbus,this),e(this,ve).off(`${y}:async:destroy:manager`,this._destroyEventbus,this),e(this,ve).off(`${y}:async:remove`,this._removeEventbus,this),e(this,ve).off(`${y}:async:remove:all`,this._removeAllEventbus,this),e(this,ve).off(`${y}:get:enabled`,this.getEnabled,this),e(this,ve).off(`${y}:get:options`,this.getOptions,this),e(this,ve).off(`${y}:get:plugin:by:event`,this.getPluginByEvent,this),e(this,ve).off(`${y}:get:plugin:data`,this.getPluginData,this),e(this,ve).off(`${y}:get:plugin:events`,this.getPluginEvents,this),e(this,ve).off(`${y}:get:plugin:names`,this.getPluginNames,this),e(this,ve).off(`${y}:has:plugin`,this.hasPlugins,this),e(this,ve).off(`${y}:is:valid:config`,this.isValidConfig,this),e(this,ve).off(`${y}:set:enabled`,this._setEnabledEventbus,this),e(this,ve).off(`${y}:set:options`,this._setOptionsEventbus,this)),h.on(`${p}:async:add`,this._addEventbus,this,{guard:!0}),h.on(`${p}:async:add:all`,this._addAllEventbus,this,{guard:!0}),h.on(`${p}:async:destroy:manager`,this._destroyEventbus,this,{guard:!0}),h.on(`${p}:async:remove`,this._removeEventbus,this,{guard:!0}),h.on(`${p}:async:remove:all`,this._removeAllEventbus,this,{guard:!0}),h.on(`${p}:get:enabled`,this.getEnabled,this,{guard:!0}),h.on(`${p}:get:options`,this.getOptions,this,{guard:!0}),h.on(`${p}:get:plugin:by:event`,this.getPluginByEvent,this,{guard:!0}),h.on(`${p}:get:plugin:data`,this.getPluginData,this,{guard:!0}),h.on(`${p}:get:plugin:events`,this.getPluginEvents,this,{guard:!0}),h.on(`${p}:get:plugin:names`,this.getPluginNames,this,{guard:!0}),h.on(`${p}:has:plugin`,this.hasPlugins,this,{guard:!0}),h.on(`${p}:is:valid:config`,this.isValidConfig,this,{guard:!0}),h.on(`${p}:set:enabled`,this._setEnabledEventbus,this,{guard:!0}),h.on(`${p}:set:options`,this._setOptionsEventbus,this,{guard:!0});for(const w of e(this,Te))w.setEventbus({oldEventbus:e(this,ve),newEventbus:h,oldPrepend:y,newPrepend:p});for(const p of e(this,be))p.setEventbus(h);t(this,ve,h)}setOptions(h){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!ae(h))throw new TypeError("'options' is not an object.");"boolean"==typeof h.noEventAdd&&(e(this,Ee).noEventAdd=h.noEventAdd),"boolean"==typeof h.noEventDestroy&&(e(this,Ee).noEventDestroy=h.noEventDestroy),"boolean"==typeof h.noEventRemoval&&(e(this,Ee).noEventRemoval=h.noEventRemoval),"boolean"==typeof h.noEventSetEnabled&&(e(this,Ee).noEventSetEnabled=h.noEventSetEnabled),"boolean"==typeof h.noEventSetOptions&&(e(this,Ee).noEventSetOptions=h.noEventSetOptions),"boolean"==typeof h.throwNoMethod&&(e(this,Ee).throwNoMethod=h.throwNoMethod),"boolean"==typeof h.throwNoPlugin&&(e(this,Ee).throwNoPlugin=h.throwNoPlugin);for(const p of e(this,Te))p.setOptions(h)}_setOptionsEventbus(h){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");e(this,Ee).noEventSetOptions||this.setOptions(h)}}var xe=new WeakMap;class Me{constructor(h){s(this,xe,{writable:!0,value:null}),t(this,xe,h)}get isDestroyed(){return null===e(this,xe)||e(this,xe).isDestroyed}get options(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,xe).getOptions()}get pluginManager(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return e(this,xe)}async destroy({eventbus:h,eventPrepend:p}){null!=h&&(h.off(`${p}:async:invoke`,this.invokeAsync,this),h.off(`${p}:async:invoke:event`,this.invokeAsyncEvent,this),h.off(`${p}:get:method:names`,this.getMethodNames,this),h.off(`${p}:has:method`,this.hasMethod,this),h.off(`${p}:invoke`,this.invoke,this),h.off(`${p}:sync:invoke`,this.invokeSync,this),h.off(`${p}:sync:invoke:event`,this.invokeSyncEvent,this)),t(this,xe,null)}getMethodNames({enabled:h,plugins:p=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(void 0!==h&&"boolean"!=typeof h)throw new TypeError("'enabled' is not a boolean.");if("string"!=typeof p&&!oe(p))throw new TypeError("'plugins' is not a string or iterable.");"string"==typeof p&&(p=[p]);const y=void 0===h,w={};let b=0;for(const E of p){const p=this.pluginManager.getPluginEntry(E);if(void 0!==p&&p.instance&&(y||p.enabled===h))for(const h of $e(p.instance))"function"==typeof p.instance[h]&&"constructor"!==h&&(w[h]=!0);b++}if(0===b)for(const p of this.pluginManager.getPluginMapValues())if(p.instance&&(y||p.enabled===h))for(const h of $e(p.instance))"function"==typeof p.instance[h]&&"constructor"!==h&&(w[h]=!0);return Object.keys(w).sort()}hasMethod({method:h,plugins:p=[]}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h)throw new TypeError("'method' is not a string.");if("string"!=typeof p&&!oe(p))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof p){const y=this.pluginManager.getPluginEntry(p);return void 0!==y&&"function"==typeof y.instance[h]}let y=0;for(const w of p){const p=this.pluginManager.getPluginEntry(w);if(void 0!==p&&"function"!=typeof p.instance[h])return!1;y++}if(0===y)for(const p of this.pluginManager.getPluginMapValues())if("function"!=typeof p.instance[h])return!1;return!0}invoke({method:h,args:p,plugins:y}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h)throw new TypeError("'method' is not a string.");if(void 0!==p&&!Array.isArray(p))throw new TypeError("'args' is not an array.");if(void 0===y&&(y=this.pluginManager.getPluginMapKeys()),"string"!=typeof y&&!oe(y))throw new TypeError("'plugins' is not a string or iterable.");let w=!1,b=!1;const E=Array.isArray(p);if("string"==typeof y){const m=this.pluginManager.getPluginEntry(y);void 0!==m&&m.enabled&&m.instance&&(b=!0,"function"==typeof m.instance[h]&&(E?m.instance[h](...p):m.instance[h](),w=!0))}else for(const m of y){const y=this.pluginManager.getPluginEntry(m);void 0!==y&&y.enabled&&y.instance&&(b=!0,"function"==typeof y.instance[h]&&(E?y.instance[h](...p):y.instance[h](),w=!0))}if(this.options.throwNoPlugin&&!b)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!w)throw new Error(`PluginManager failed to invoke '${h}'.`)}async invokeAsync({method:h,args:p,plugins:y}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h)throw new TypeError("'method' is not a string.");if(void 0!==p&&!Array.isArray(p))throw new TypeError("'args' is not an array.");if(void 0===y&&(y=this.pluginManager.getPluginMapKeys()),"string"!=typeof y&&!oe(y))throw new TypeError("'plugins' is not a string or iterable.");let w,b=!1,E=!1;const m=[],P=Array.isArray(p);if("string"==typeof y){const T=this.pluginManager.getPluginEntry(y);void 0!==T&&T.enabled&&T.instance&&(E=!0,"function"==typeof T.instance[h]&&(w=P?T.instance[h](...p):T.instance[h](),void 0!==w&&m.push(w),b=!0))}else for(const T of y){const y=this.pluginManager.getPluginEntry(T);void 0!==y&&y.enabled&&y.instance&&(E=!0,"function"==typeof y.instance[h]&&(w=P?y.instance[h](...p):y.instance[h](),void 0!==w&&m.push(w),b=!0))}if(this.options.throwNoPlugin&&!E)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!b)throw new Error(`PluginManager failed to invoke '${h}'.`);return m.length>1?Promise.all(m).then((h=>{const p=h.filter((h=>void 0!==h));switch(p.length){case 0:return;case 1:return p[0];default:return p}})):w}async invokeAsyncEvent({method:h,copyProps:p={},passthruProps:y={},plugins:w}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return ce({method:h,manager:this.pluginManager,copyProps:p,passthruProps:y,plugins:w})}invokeSync({method:h,args:p,plugins:y}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof h)throw new TypeError("'method' is not a string.");if(void 0!==p&&!Array.isArray(p))throw new TypeError("'args' is not an array.");if(void 0===y&&(y=this.pluginManager.getPluginMapKeys()),"string"!=typeof y&&!oe(y))throw new TypeError("'plugins' is not a string or iterable.");let w,b=!1,E=!1;const m=[],P=Array.isArray(p);if("string"==typeof y){const T=this.pluginManager.getPluginEntry(y);void 0!==T&&T.enabled&&T.instance&&(E=!0,"function"==typeof T.instance[h]&&(w=P?T.instance[h](...p):T.instance[h](),void 0!==w&&m.push(w),b=!0))}else for(const T of y){const y=this.pluginManager.getPluginEntry(T);void 0!==y&&y.enabled&&y.instance&&(E=!0,"function"==typeof y.instance[h]&&(w=P?y.instance[h](...p):y.instance[h](),void 0!==w&&m.push(w),b=!0))}if(this.options.throwNoPlugin&&!E)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!b)throw new Error(`PluginManager failed to invoke '${h}'.`);return m.length>1?m:w}invokeSyncEvent({method:h,copyProps:p={},passthruProps:y={},plugins:w}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return function({method:h,manager:p,copyProps:y={},passthruProps:w={},plugins:b,options:E,errorCheck:m=!0}){if("string"!=typeof h)throw new TypeError("'method' is not a string.");if("object"!=typeof w)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof y)throw new TypeError("'copyProps' is not an object.");if(void 0===E&&(E=p.getOptions()),void 0===b&&(b=p.getPluginMapKeys()),"string"!=typeof b&&!oe(b))throw new TypeError("'plugins' is not a string or iterable.");let P=0;const T=[];let k=!1,W=!1;const L=new le(y,w);if("string"==typeof b){const y=p.getPluginEntry(b);void 0!==y&&y.enabled&&y.instance&&(W=!0,"function"==typeof y.instance[h]&&(L.eventbus=y.eventbusProxy,L.pluginName=y.name,L.pluginOptions=y.data.plugin.options,y.instance[h](L),k=!0,P++,T.push(y.name)))}else for(const y of b){const w=p.getPluginEntry(y);void 0!==w&&w.enabled&&w.instance&&(W=!0,"function"==typeof w.instance[h]&&(L.eventbus=w.eventbusProxy,L.pluginName=w.name,L.pluginOptions=w.data.plugin.options,w.instance[h](L),k=!0,P++,T.push(w.name)))}if(m&&E.throwNoPlugin&&!W)throw new Error("PluginManager failed to find any target plugins.");if(m&&E.throwNoMethod&&!k)throw new Error(`PluginManager failed to invoke '${h}'.`);return L.data.$$plugin_invoke_count=P,L.data.$$plugin_invoke_names=T,L.data}({method:h,manager:this.pluginManager,copyProps:p,passthruProps:y,plugins:w})}setEventbus({oldEventbus:h,newEventbus:p,oldPrepend:y,newPrepend:w}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");null!=h&&(h.off(`${y}:async:invoke`,this.invokeAsync,this),h.off(`${y}:async:invoke:event`,this.invokeAsyncEvent,this),h.off(`${y}:get:method:names`,this.getMethodNames,this),h.off(`${y}:has:method`,this.hasMethod,this),h.off(`${y}:invoke`,this.invoke,this),h.off(`${y}:sync:invoke`,this.invokeSync,this),h.off(`${y}:sync:invoke:event`,this.invokeSyncEvent,this)),null!=p&&(p.on(`${w}:async:invoke`,this.invokeAsync,this,{guard:!0}),p.on(`${w}:async:invoke:event`,this.invokeAsyncEvent,this,{guard:!0}),p.on(`${w}:get:method:names`,this.getMethodNames,this,{guard:!0}),p.on(`${w}:has:method`,this.hasMethod,this,{guard:!0}),p.on(`${w}:invoke`,this.invoke,this,{guard:!0}),p.on(`${w}:sync:invoke`,this.invokeSync,this,{guard:!0}),p.on(`${w}:sync:invoke:event`,this.invokeSyncEvent,this,{guard:!0}))}setOptions(h){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.")}}const $e=h=>{const p=[];do{Object.getOwnPropertyNames(h).forEach((h=>{-1===p.indexOf(h)&&p.push(h)})),h=Object.getPrototypeOf(h)}while(null!=h&&h!==Object.prototype);return p};export{v as Eventbus,I as EventbusProxy,B as EventbusSecure,Me as PluginInvokeSupport,ke as default,ge as escapeTarget,q as eventbus,pe as isValidConfig,F as pluginEventbus,H as testEventbus};
//# sourceMappingURL=manager.js.map
